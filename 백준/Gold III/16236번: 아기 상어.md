[https://www.acmicpc.net/problem/16236](https://www.acmicpc.net/problem/16236)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

let inputIndex = 0;

// 공간의 크기 2~20
const N = Number(input[inputIndex++]);

// 공간 상태
const maps = [];
for (let i = 0; i < N; i++) {
    maps.push(input[inputIndex++].split(' ').map(Number));
}

// 상어 초기 위치
let initY;
let initX;
for (let y = 0; y < N; y++) {
    for (let x = 0; x < N; x++) {
        if (maps[y][x] === 9) {
            initY = y;
            initX = x;
            break;
        }
    }
}
maps[initY][initX] = 0; // 상어 위치 초기화

// 아기 상어 크기
let sharkSize = 2;

// 상어가 먹은 물고기 수. sharksSize크기만큼 도달했을 때 0으로 초기화된다.
let eatedFishs = 0;

const dy = [-1, 0, 1, 0];
const dx = [0, 1, 0, -1];

let answer = 0;

// 상어가 이동할 물고기를 파악하는 BFS
function bfs(y, x) {
    // 방문 여부
    const visited = Array.from({ length: N }, () => Array(N).fill(false));

    const queue = [];
    let head = 0;
    // 큐에 들어가는 정보: [y, x, 이동 거리]

    queue.push([y, x, 0]); // 초기값
    visited[y][x] = true;

    // 최소 거리
    let minDistance = Infinity;

    // 물고기 후보 배열. 먹을 수 있어야 함.
    const fishList = [];

    // 맵 전체를 탐색하며 먹을 수 있는 물고기인지 확인한다.
    while (queue.length > head) {
        // 탐색 위치
        const [curY, curX, curDist] = queue[head++];

        // 일단 최소 거리보다 멀어지면 더이상 볼 필요가 없다.
        if (curDist > minDistance) {
            break;
        }

        // 1) 물고기가 있고, 2) 먹을 수 있는 물고기인가?
        if (maps[curY][curX] !== 0 && maps[curY][curX] < sharkSize) {
            // 후보 등록.
            fishList.push([curY, curX, curDist]);

            // 거리 갱신
            minDistance = curDist;
        }

        // 이동 조건 탐색
        for (let i = 0; i < 4; i++) {
            const ny = curY + dy[i];
            const nx = curX + dx[i];

            // 후보 조건1) 유효한 범위 조건2) 물고기 크기가 상어보다 작거나 같아야 함 조건3) 방문하지 않음
            if (ny >= 0 && nx >= 0 && ny < N && nx < N && maps[ny][nx] <= sharkSize && visited[ny][nx] === false) {
                // 방문 표시 후 이동
                visited[ny][nx] = true;

                queue.push([ny, nx, curDist + 1]);
            }
        }
    }
    // 탐색 끝. 이제 이동 후보 물고기 중에서 하나를 결정
    // 정렬1) y축 기준 오름차,  정렬2) x축 기준 오름차
    fishList.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
    return fishList[0];
}

// 상어 출발
while (true) {
    // 현재 위치에서 BFS 탐색. 잡아먹을 물고기 결과를 반환한다.
    const fish = bfs(initY, initX);

    // 물고기가 없다면? 엄마 상어 호출
    if (fish === undefined) {
        break;
    }

    // 물고기가 있다면? 해당 위치로 이동
    initY = fish[0];
    initX = fish[1];
    maps[initY][initX] = 0; // 물고기 삭제

    // 거리 계산
    answer += fish[2];

    // 물고기 먹음
    eatedFishs++;

    // 현재 크기만큼 먹었다면 진화
    if (eatedFishs === sharkSize) {
        sharkSize++;
        eatedFishs = 0; // 누적 물고기는 초기화
    }
}
console.log(answer);
```
### 🔗 풀이
1. 💡 아기 상어와 물고기
      1. 크기가 같으면 지나갈 수는 있음
      2. 크기가 작아야 먹을 수 있음
      3. 가장 가까운 물고기를 먹되, 왼쪽 위 물고기를 먼저 먹는다.
          - 🤔 "왼쪽 위에 있다" 라는 것은 어떻게 판단할까?

2. 💡 조건 상세 분석
    - ⭐️ 이동을 한 칸씩 가는 것이고, 먹으러 갈 때는 굳이 인접하지 않아도 됨.

3. 🤔 물고기 위치를 좌표로 주지 않는다.
    - 직접 파악해야하나?
      - 맨 처음에 확인하자.

4. 🤔 필요한 변수가 무엇일까?
    1. 아기 상어 좌표 (초기 위치만 설정하고 BFS)
    2. 아기 상어 현재 크기
    3. 아기 상어가 레벨업하기 위해 필요할 누적 섭취 물고기 수(물고기 크기는 상관 없음)
    4. 물고기 현황판. (주어진 정보 사용)
    5. 시간
        - 상하좌우로 이동할때마다 +1

5. 🤔 먹을 수 있는 물고기가 있는지 어떻게 판단할까?
    - 매 초마다 순회하면서 확인한다?
        - 👀 ❌ 방법1)
              1. 우선 순위 힙을 사용한다
              2. 🚨 근데, 아기 상어가 이동할 때마다 거리를 갱신해야해한다.
              3. 아기 상어가 커질 때마다 우선 순위 큐를 다시 만든다?
              4. 우선 순위 기준은 뭐로 해야 하나? -> 일단 그냥 순회해보고, 나중에 우선순위 도입해보자

6. 👀 ❌ 방법2) 일단 자연어로 풀어보자.
    1. 먹을 수 있는 물고기를 파악한다.
    2. 거리가 어떻게 되는지 파악한다, 왼쪽 위 물고기인가 파악한다.
        - 👀 방법 2)
            1. 상좌하우 순서로 DFS하면 상단 왼쪽부터 확인할 수 있지 않을까? -> 🚨 DFS로 풀면 안된다.
            2. 먹을 수 있는 물고기를 발견했다면 stop
            3. 이동할 때 +1
    3. 먹고나서 아기 상어 크기가 커진다.
    4. 반복한다.

7. 👀 ✅ 방법3) BFS로 풀어야 한다.
    1. 매번 위치에서 BFS한다.
    2. BFS에서 최단 거리 모든 물거기를 우선 모으고, 정렬해서 이동할 물고기 위치를 파악한다.
    3. BFS결과에 따라 탐색을 중단하던, 위치로 이동 후 이동한 거리를 누적한다.
       
### 🔗 배운점
1. BFS 함수를 어떻게 분리할 것인가 설계하는 힘을 기르자.
    - 그동안 BFS는 따로 분리하지 않았다. 그러다보니 이 문제에서 어떤 식으로 설계해야할지 헷갈린듯.
    - BFS이 어떤 역할을 할지 정하고, 설계하자.
        - 🤔 이 문제에서 BFS의 역할은?
            1. 이동할 수 있는 최단거리 위치 목록 파악
            2. 이동할 위치 반환
            3. 이동 거리도 반환

2. 근데 이런식으로 풀었을 때, bfs마다 방문 여부 배열을 만들어도 되는지, 시간복잡도는 왜 괜찮은지 어떻게 판단할까?
    1. 맵의 크기 최대 400칸
    2. BFS 1회 비용: 400회
    3. 최대 반복 횟수: 물고기가 맵에 전부 차있음: BFS를 400번
