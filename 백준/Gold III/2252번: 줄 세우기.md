[https://www.acmicpc.net/problem/2252](https://www.acmicpc.net/problem/2252)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

let inputIndex = 0;

// N명을 줄세우는데 M번 비교함.
const [N, M] = input[inputIndex++].split(' ').map(Number);

// 진입 차수
const inDegree = Array.from({ length: N + 1 }, () => 0);
const adjList = Array.from({ length: N + 1 }, () => []);

// 호흡1) 관계도 파악 - 인접 리스트로 결정 -> 이긴 사람에게 딸려있는 진 사람 리스트. 즉, adList[i]값은 전부 i보다 뒤쪽 순위여야 한다.
for (let i = 0; i < M; i++) {
    const [fir, sec] = input[inputIndex++].split(' ').map(Number);
    adjList[fir].push(sec);
    // 진입 차수 증가
    inDegree[sec]++;
}

// 진입 차수가 없는 녀석들 큐에 넣기
const q = [];
for (let i = 1; i <= N; i++) {
    if (inDegree[i] === 0) {
        q.push(i); // 3, 4
    }
}
// 진입 차수가 없는 친구들 (큐에서 꺼낸 친구들) 넣기. 넣는 순서대로 위상 정렬 적용
const result = [];

let head = 0;
while (q.length > head) {
    const curNode = q[head++];

    result.push(curNode);

    // 현재 노드와 연결된 이웃 노드들의 진입 차수 감소
    for (const n of adjList[curNode]) {
        // 진입 차수 감소
        inDegree[n]--;
        if (inDegree[n] === 0) {
            q.push(n);
        }
    }
}

console.log(result.join(' '));
```
### 🔗 풀이
1. 💡 호흡 나누기
    1. 학생 간 관계도 파악하기
    2. 줄을 어떻게 세울 것인가?
       - 위상 정렬을 사용해야 한다.

🤔 인접 리스트로 구현해볼까?
    - `adjList[i] = []`   -> i번째 학생 뒤에 있는 학생 리스트
    - 왜 인접 리스틀르 써야할까?
        - 모든 학생을 비교한 것이 아니다. 일단 주어진 조건을 활용하기 위해 관계도를 그려보자.

🤔 답이 여러 가지인 경우에는 아무거나 출력?
    - 주어진 `M`번의 비교로는 완전한 순위를 매길 수 없다는 의미이다.

🤔 위상 정렬 구현하기
    1. 제일 앞에 올 수 있는 요소들 파악하기
        - `indegree가 0`인 요소들 파악하기

### 🔗 배운점
1. 위상 정렬이란
   > 방향 그래프에서 간선으로 주어진 정점 간 선후관계를 위배하지 않도록 정렬하는 알고리즘
   - 그래프에서 사이클이 존재한다면 위상 정렬이 존재하지 않는다. -> 사이클이 존재하지 않는 방향 그래프 : DAG
2. 이 문제에서 왜 위상 정렬을 떠올려야 하는가?
   - 선후 관계를 강조한다.
   - 문제에서 비교가 일부만 주어져서 정답이 여러 개 가능하다면 위상 정렬 가능성이 크다.
   - 사이클이 없는 방향 그래프가 주어지면 위상 정렬일 가능성이 높다.
4. 위상 정렬을 코드로 구현하기
    ```javascript
      function topologicalSort(numVertices, edges) {
          // 1. 진입 차수(In-degree)와 인접 리스트 초기화
          const inDegree = new Array(numVertices).fill(0);
          const adjList = Array.from({ length: numVertices }, () => []);
      
          // 2. 그래프 구조 빌드 및 진입 차수 계산
          for (const [u, v] of edges) {
              adjList[u].push(v);
              inDegree[v]++;
          }
      
          // 3. 진입 차수가 0인(의존성이 없는) 모든 정점을 큐에 삽입
          const queue = [];
          for (let i = 0; i < numVertices; i++) {
              if (inDegree[i] === 0) {
                  queue.push(i);
              }
          }
      
          const result = [];
      
          // 4. 큐에서 정점을 하나씩 꺼내며 연결된 간선 제거
          while (queue.length > 0) {
              const current = queue.shift();
              result.push(current);
      
              // 현재 노드와 연결된 이웃 노드들의 진입 차수 감소
              for (const neighbor of adjList[current]) {
                  inDegree[neighbor]--;
      
                  // 진입 차수가 0이 되면 큐에 추가
                  if (inDegree[neighbor] === 0) {
                      queue.push(neighbor);
                  }
              }
          }
      
          // 5. 사이클 존재 여부 확인
          // 정렬된 결과의 길이가 전체 정점 수와 다르다면 사이클이 존재한다는 의미
          if (result.length !== numVertices) {
              return false;
          }
      
          return result;
      }
    ```
      1. 모든 노드의 진입 차수를 저장하는 `inDegree` 배열 필요
      2. 인접 리스트드 필요. A->B 등
      3. 큐에 진입 차수가 0인 요소 넣기 (자유로운)
      4. 큐가 빌 때까지 반복.
      5. 큐에서 나오면 바로 `result`배열에 넣기.
      6. 이웃 노드들의 진입 차수 감소
      7. 진입 차수가 0이 될 때마다 큐에 넣기
      8. 마지막에 `result`길이가 원래 노드 길이와 같지 않다면 순환이 발생한 것이다.
