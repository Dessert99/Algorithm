[https://www.acmicpc.net/problem/11666](https://www.acmicpc.net/problem/11666)
```javascript
    const input = require('fs')
        .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
        .toString()
        .trim()
        .split('\n');

    class MinHeap {
        constructor() {
            this.heap = [];
        }
        swap(i1, i2) {
            [this.heap[i1], this.heap[i2]] = [this.heap[i2], this.heap[i1]];
        }
        getLeftChildIndex(curIndex) {
            return curIndex * 2 + 1;
        }
        getRightChildIndex(curIndex) {
            return curIndex * 2 + 2;
        }
        getParentIndex(curIndex) {
            return Math.floor((curIndex - 1) / 2);
        }

        insert(value) {
            this.heap.push(value);
            this.heapifyUp();
        }
        heapifyUp() {
            let curIndex = this.heap.length - 1;

            while (curIndex > 0) {
                const parentIndex = this.getParentIndex(curIndex);

                // 제자리에 돌아 갔다는 것은, 부모가 더 작다는 것.
                if (this.heap[parentIndex] <= this.heap[curIndex]) {
                    break;
                }
                this.swap(curIndex, parentIndex);
                curIndex = parentIndex;
            }
        }

        extractMin() {
            if (this.heap.length === 0) {
                return null;
            }
            if (this.heap.length === 1) {
                return this.heap.pop();
            }

            const min = this.heap[0];
            this.heap[0] = this.heap.pop();

            this.heapifyDown();

            return min;
        }

        heapifyDown() {
            let curIndex = 0;
            const n = this.heap.length;

            while (true) {
                const leftChildIndex = this.getLeftChildIndex(curIndex);
                const rightChildIndex = this.getRightChildIndex(curIndex);
                let minIndex = curIndex;

                // 왼쪽 자식의 값이 더 작다면 내려가야 한다.
                if (leftChildIndex < n && this.heap[leftChildIndex] < this.heap[minIndex]) {
                    minIndex = leftChildIndex;
                }
                if (rightChildIndex < n && this.heap[rightChildIndex] < this.heap[minIndex]) {
                    minIndex = rightChildIndex;
                }
                if (curIndex === minIndex) {
                    break;
                }

                this.swap(minIndex, curIndex);
                curIndex = minIndex;
            }
        }
    }

    let inputIndex = 0;
    // n: 연구원의 수 30만, m: 워크스테이션 잠기는 시간 1억
    const [n, m] = input[inputIndex++].split(' ').map(Number);

    // 이후 연구원 일정 [들어온 시간, 진행 시간]
    const schedules = [];
    for (let i = 0; i < n; i++) {
        schedules.push(input[inputIndex++].split(' ').map(Number));
    }
    // [들어온 시간, 나가는 시간] 으로 바꿔주자
    for (let i = 0; i < n; i++) {
        // 현재 연구원 스케줄
        const cur = schedules[i]; // 참조 주소를 가져온다.
        // 진행 시간
        const time = cur.pop();
        // 종료 시간
        const end = cur[0] + time;
        // 배열에 넣기
        cur.push(end);
    }
    // 시작 시간 기준 정렬
    schedules.sort((a, b) => a[0] - b[0]);

    // 우선순위 큐: 컴퓨터의 종료 시간이 들어간다. 루트에 있는 요소는 가장 오래된 컴퓨터!
    const pq = new MinHeap();

    // 절약한 컴퓨터 수
    let answer = 0;

    // 순회
    for (let i = 0; i < n; i++) {
        // 현재 연구원 일정
        const [start, end] = schedules[i];

        // ⭐️ 우선, 일찍 끝났지만 m시간을 초과한 컴퓨터는 절약할 수 없다. 전부 빼내자.
        while (pq.heap.length > 0 && pq.heap[0] + m < start) {
            // 마지막으로 끝난 시간 + m이 지금 시작 시간보다 작다면 커진다.
            pq.extractMin();
        }

        // 가장 빨리 끝난 컴퓨터 파악. 이게 start이하라면 배정 가능
        if (pq.heap.length > 0 && pq.heap[0] <= start) {
            // 배정 완료. 절약 성공
            answer++;
            pq.extractMin();
        }

        // 연구원이 다 썼으면 pq에 넣기.
        pq.insert(end);
    }

    console.log(answer);
```
### 🔗 풀이
1. 🤔 일단 보기 편하게 [시작 시간, 종료 시간] 으로 데이터를 정리하면 어떨까?
        - 지금 [시작 시간, 진행 시간] 으로 데이터가 보이니 언제 끝나는지 파악하기 어렵다. 정렬할 때도 바꾼 기준이 유용할 것 같다.
2. 🤔 그리디인가?
        - 만약 종료 시간 기준으로 오름차순 정렬하고, 잇는다면 최대 효율일까?
### 🔗 배운점
1. ⭐️ 필수 사고 과정
    1. 모든 사람의 여러 방에 배정하여 상태를 추적한다.
        - 시작 시간 오름차 정렬이 필요하다.
    2. 조건을 만족하는 것 중, 가장 먼저 끝난 방을 찾아야 한다.
        - 우선순위 큐를 떠올려야 한다. 매번 어떤 컴퓨터가 급한지 계산할 수 없다. 
2. ⭐️ 우선순위 큐 근거
    - 컴퓨터마다 꺼지는 시간 상태를 갖고 있다. 우리는 실시간으로 꺼지기 직업 컴퓨터에 배정해야 하기 때문에 이를 저장할 우선순위 큐가 필요하다.
3. 🚨 스위핑 주의사항
   - 스위핑의 본질은 정렬과 스캔이다.
   - [선긋기] 문제처럼 범위를 잇는다고 생각하면 이 문제는 풀 수 없다.
   - 이 문제에서 사용된 스위핑 사고 과정은 다음과 같다.
     1. 연구 시작 시간 마다 어느 방으로 들어갈지 결정해야 한다. -> 시작 시간 기준으로 정렬이 필요하구나
     2. 지금 컴퓨터 상태를 보고 기준에 부합하면 방으로 들어간다.
4. 발상의 전환
   - "방에 들어간 횟수"가 필요한게 아니라, 절약한 횟수가 필요하다.
