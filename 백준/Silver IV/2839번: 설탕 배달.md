[https://www.acmicpc.net/problem/2839](https://www.acmicpc.net/problem/2839)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

const N = Number(input);

// 무게 i를 만들 수 있는 최소 봉지 개수를 누적하는 dp배열. 계산에 용이하게 +1
const dp = Array.from({ length: N + 1 }, () => 5001);

// 초기값. 3kg
dp[3] = 1;
if (N >= 5) {
    dp[5] = 1;
}

// 반복문을 도는 이유 -> dp배열을 채우기 위해서
// 6부터 시작하는 이유 -> dp[5]를 이미 채워놨고, dp[4]는 어짜피 무의미한 값이기 때문에 나중에 -1이 출력된다.
for (let i = 6; i <= N; i++) {
    // 점화식: min(dp[i-3], dp[i-5]) + 1
    dp[i] = Math.min(dp[i - 3], dp[i - 5]) + 1;
}

let answer;

if (dp[N] >= 5001) {
    //만약 3kg, 5kg로 설탕 무게를 만들 수 없는 경우
    answer = -1;
} else {
    answer = dp[N];
}

console.log(answer);
```
### 🔗 질문
1. 왜 반목문을 돌아야 하는가?
   - `dp`배열을 채우기 위해서. 왜 `dp`배열을 채울까? `dp`배열에 저장된 이전값으로 현재값을 빠르고 효율적으로 구하기 위해서.
2. 이 문제에서 "이전값" 사용 방법
   - 피보나치는 -1, -2 번째 값을 이용해 현재 값을 구한다. 이 문제는 설탕의 무게가 3kg, 5kg 둘 중 하나이다. 그래서 -3, -5 이전값을 사용한다.

### 🔗 배운점
1. DP 접근법: dp[] 배열 의미
   - dp 배열에는 "최소 봉지 개수"를 저장한다.
   - $dp[i]$는 무게 $i$를 만들기 위한 봉지의 최소 개수이다.
3. DP 접근법: 점화식을 세워야한다.
   > $dp[i] = min(dp[i-3], dp[i-5]) + 1$
   - 현재 무게에 필요한 설탕 개수는, -3kg일 때, -5kg일 때 중 숫자가 작은 누적값에 1을 더한 값이다.
5. DP 접근법: 3kg, 5kg로 만들 수 없는 값은 어떻게 저장할까?
   - `Math.min()` 값에 방해되지 않도록 최대한 높은 숫자로 저장한다.
   - 나중에 -1을 출력하도록 설정하면 된다.
7. DP 접근법: 반복문을 돌며 DP 배열을 채워야 하는 이유
   - `dp`배열을 채워야 한다.
