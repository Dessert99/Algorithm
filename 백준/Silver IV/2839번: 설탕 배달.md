[https://www.acmicpc.net/problem/2839](https://www.acmicpc.net/problem/2839)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

// 배달해야 할 무게 (3~5000)
const N = Number(input[0]);

// dp[i] = 무게가 i kg일 때 필요한 최소 봉지 수
// 길이를 5001로 하는 이유: dp[5] = 1을 미리 해놓기 위해서.
const dp = Array.from({ length: 5001 }, () => 5001);

// 초기값 설정.
dp[3] = 1;
dp[5] = 1;

// 6kg부터 Nkg까지 쭉 계산해본다.
for (let i = 6; i <= N; i++) {
    // 현재 무게(i)를 만드는 최소 방법 찾기

    // 방법 1: 3kg짜리 봉지를 하나 더 쓴다. (즉, i - 3kg 때의 최적해 + 1개)
    const case3kg = dp[i - 3];

    // 방법 2: 5kg짜리 봉지를 하나 더 쓴다. (즉, i - 5kg 때의 최적해 + 1개)
    const case5kg = dp[i - 5];

    // 둘 중에 더 봉지 수가 적은 방법을 선택해서 1(이번 봉지)을 더합니다.
    dp[i] = Math.min(case3kg, case5kg) + 1;
}
let answer;

// 만약 dp[N]이 여전히 5001 이상이라면? -> 어떤 방법으로도 만들 수 없었다는 뜻.
if (dp[N] >= 5001) {
    console.log(-1);
} else {
    console.log(dp[N]);
}
```
### 🔗 질문
1. 왜 반목문을 돌아야 하는가?
   - `dp`배열을 채우기 위해서. 왜 `dp`배열을 채울까? `dp`배열에 저장된 이전값으로 현재값을 빠르고 효율적으로 구하기 위해서.
2. 이 문제에서 "이전값" 사용 방법
   - 피보나치는 -1, -2 번째 값을 이용해 현재 값을 구한다. 이 문제는 설탕의 무게가 3kg, 5kg 둘 중 하나이다. 그래서 -3, -5 이전값을 사용한다.

### 🔗 배운점
1. DP 접근법: dp[] 배열 의미
   - dp 배열에는 "최소 봉지 개수"를 저장한다.
   - $dp[i]$는 무게 $i$를 만들기 위한 봉지의 최소 개수이다.
3. DP 접근법: 점화식을 세워야한다.
   > $dp[i] = min(dp[i-3], dp[i-5]) + 1$
   - 현재 무게에 필요한 설탕 개수는, -3kg일 때, -5kg일 때 중 숫자가 작은 누적값에 1을 더한 값이다.
5. DP 접근법: 3kg, 5kg로 만들 수 없는 값은 어떻게 저장할까?
   - `Math.min()` 값에 방해되지 않도록 최대한 높은 숫자로 저장한다.
   - 나중에 -1을 출력하도록 설정하면 된다.
7. DP 접근법: 반복문을 돌며 DP 배열을 채워야 하는 이유
   - `dp`배열을 채워야 한다.
