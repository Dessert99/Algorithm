[https://www.acmicpc.net/problem/17266](https://www.acmicpc.net/problem/17266)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

let answer = 0;

// 굴다리 길이 1~10만
const N = Number(input[0]);

// 가로등의 개수 1~N
const M = Number(input[1]);

// M개의 가로등 위치 배열
const streetLightPositions = input[2].split(' ').map(Number);

// 가로등의 최소 높이: 1
let start = 1;

// 가로등의 최대 높이: 굴다리(N) 길이만큼
let end = N;

// 굴다리를 모두 비출 수 있는 조건. 현재 가로등 높이를 입력받고, true/false를 반환한다.
function isChecked(height) {
    // 첫 번째 가로등이 시작 지점까지 닿는가? 높이가 첫 번째 가로등 위치 이상이어야 함.
    if (streetLightPositions[0] > height) {
        return false;
    }
    // 가로등 사이만 확인하면 된다.
    for (let i = 0; i < streetLightPositions.length - 1; i++) {
        const gap = streetLightPositions[i + 1] - streetLightPositions[i];

        // 만약 차이가 가로등의 높이*2 보다 크면 안된다.
        if (gap > height * 2) {
            return false;
        }
    }
    // 마지막 가로등이 끝까지 빛을 비추는가?
    if (N - streetLightPositions[streetLightPositions.length - 1] > height) {
        return false;
    }

    // 여기까지 오면 통과
    return true;
}

// 이분 탐색 시작
while (start <= end) {
    // 중간값: 현재 가로등 높이
    const mid = Math.floor((start + end) / 2);

    // 굴다리를 모두 비출 수 있다면 -> mid값을 낮춰서 다시 구해본다.
    if (isChecked(mid)) {
        //일단 정답 저장
        answer = mid;
        end = mid - 1;
    } else {
        start = mid + 1;
    }
}

console.log(answer);
```
### 🔗 배운점
1. 이분 탐색 주의점
    > 이분 탐색 문제 중 "좌표"나 "거리"를 다루는 문제는, 절대로 전체 지도를 배열(`Array(N)`)로 만들어서 시뮬레이션하면 안 된다. `N`이 10억까지 커질 수 있다.
    > 
2. 굳이 `bridge`배열을 만들 필요 없이 가로등 좌표로만 풀 수 있다.
    - 모든 가로등 위치를 제공하기 때문에 이를 활용해서 빛이 어디까지 도달할 수 있는지 파악할 수 있다.
3. 현재 높이가 모든 굴다리를 비출 수 있는지 판단하는 방법
    - 처음에 사용한 방법은 “일일이 불을 비춰보는 방법”이다. 하지만 매번 새로운 배열을 복사해야하고, 메모리 초과 위험이 있다.
    - 복잡한 조건일 경우 일일이 세어 봐야겠지만 지금은 가로등 위치도 주어지고 무척 단순하다. 가로등 간 사이를 확인하고, 가로등이 비칠 수 있는 높이와 비교해서 판단하면 된다.
