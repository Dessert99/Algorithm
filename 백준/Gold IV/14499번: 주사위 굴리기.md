[https://www.acmicpc.net/problem/14499](https://www.acmicpc.net/problem/14499)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

let inputIndex = 0;

// N: 세로, M:가로, (x,y): 주사위 위치, K: 명령어 개수
const [N, M, x, y, K] = input[inputIndex++].split(' ').map(Number);

// 지도. 0인 위치는 초기 주사위 위치이다.
const maps = [];
for (let i = 0; i < N; i++) {
    maps.push(input[inputIndex++].split(' ').map(Number));
}

// 이동 명령어
const commands = input[inputIndex++].split(' ').map(Number);

// 현재 주사위 각 면의 상태를 나타내는 객체
let dice = {
    top: 0, // 윗 면
    bottom: 0, // 아랫 면
    front: 0, // 남쪽
    back: 0, // 북쪽
    left: 0, // 서쪽
    right: 0, // 동쪽
};

const answer = [];

// 주사위 현재 위치
let curY = x;
let curX = y;

// 1: 동, 2:서, 3:북, 4:남
const dy = [0, 0, 0, -1, 1];
const dx = [0, 1, -1, 0, 0];

// 명령어 입력
for (let i = 0; i < K; i++) {
    // 현재 명령어
    const curCommand = commands[i];

    // 일단 명령어로 이동할 수 있는지 검토한다.
    const ny = dy[curCommand] + curY;
    const nx = dx[curCommand] + curX;

    if (ny >= 0 && nx >= 0 && ny < N && nx < M) {
        // 이동
        curY = ny;
        curX = nx;

        //방향에 따른 주사위 면 이동
        switch (curCommand) {
            case 1: // 동쪽으로 굴릴 때 위, 오른쪽, 바닥, 왼쪽 면이 회전한다
                [dice.top, dice.right, dice.bottom, dice.left] = [dice.left, dice.top, dice.right, dice.bottom];
                break;
            case 2: // 서쪽으로 굴릴 때 위, 왼쪽, 바닥, 오른쪽 면이 회전한다.
                [dice.top, dice.left, dice.bottom, dice.right] = [dice.right, dice.top, dice.left, dice.bottom];
                break;
            case 3: // 북쪽으로 굴릴 때 위, 앞, 바닥, 뒷 면이 회전한다.
                [dice.top, dice.front, dice.bottom, dice.back] = [dice.back, dice.top, dice.front, dice.bottom];
                break;
            case 4: // 남쪽으로 굴릴 때 위, 뒤, 바닥, 앞 면이 회전한다.
                [dice.top, dice.back, dice.bottom, dice.front] = [dice.front, dice.top, dice.back, dice.bottom];
                break;
        }

        // 바닥에 적힌 숫자에 따라 변경 사항 적용
        if (maps[curY][curX] === 0) {
            // 주사위 숫자가 바닥에 복사
            maps[curY][curX] = dice.bottom;
        } else {
            // 칸에 쓰여 있는 수가 주사위의 바닥면으로 복사되며, 칸에 쓰여 있는 수는 0이 된다.

            dice.bottom = maps[curY][curX];
            maps[curY][curX] = 0;
        }

        answer.push(dice.top);
    }
}

console.log(answer.join('\n'));
```
### 🔗 풀이
1. 💡 구하고자 하는 것
    - 주사위가 이동할 때마다 상단 번호

2. 💡 예외 조건
    - 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.

3. 💡 문제 이해하기
    - 전개도에 적힌 숫자와 면에 적힌 숫자는 다르다.
    - 우리는 전개도 숫자를 기준으로 주사위 상태를 파악해야 하고, 이동할 때 면에 적히는 숫자를 통해 정답을 출력해야 한다.
    - 전개도는 주사위가 굴러가는 것을 표현하기 위해 사용하면 될 것 같다.

4. 👀 시뮬레이션
    1. 처음에 모든 칸이 0인 주사위가 (y,x) 위치에 있다. 전개도 기준은 위:1 아래:6 오른쪽:3이다.
    2. 남쪽(4)으로 굴러간다. 이때, 굴러갈 수 있는지 범위를 판단해야 한다.
    3. 이제 바닥:2 위:5 오른쪽:3이다. 2번 칸에는 3이 저장된다. 그 위치는 0이 적힌다. 이때 위는 5이다. 5에 적힌 면은 0이다.
    4. 다시 남쪽(4)으로 굴러간다.
    5. 바닥:1, 위:6, 오른쪽:3이다. 1번 칸에는 5가 저장된다. 칸은 0이된다. 이떄 위는 6이다. 여전히 0이 적혀있다.
    6. 다시 남쪽(4)으로 굴러간다.
    7. 바닥:5, 위:2. 5번 칸에는 7이 기록된다. 칸은 0이된다. 이때, 위는 2번이다. 아까 2번 칸에는 3이 저장되어서 3을 출력한다.

5. 🤔 시뮬레이션 해보고 느낀점
    - 전개도는 1:1 매핑이 되어 있다.
    - 숫자가 변하는 것은 바닥 기준이다. 이동할 때 기준은 "지금 바닥이 누구인가?"로 잡아볼까?
    - 전개도 매핑 구조
        1 - 6
        2 - 5
        4 - 3
        - 불규칙하다. 그냥 해시맵에 키 밸류로 묶어 놓을까? -> ❌ 굳이

6. 🤔 어떤 것들이 필요할까?
    1. 바닥 기준 현재 주사귀 칸에 적힌 숫자를 담는 배열? -> 길이는 7이고, 0번 인덱스는 사용하지 않는다. -> ❌
    2. 1대1 매핑되는 객체 -> 일단 바닥 기준으로 이동하고, 윗면 숫자와 매핑되는 해시맵. 다시 이 결과로 숫자 배열 인덱스로 접근해서 적힌 칸을 확인한다. -> ❌
    3. 방향 배열 -> 어디로 굴러갔냐에 따라서 "현재 바닥"이 어떻게 바뀌는지 알아야 한다.
        - 🤔 굴러가는 걸 어떻게 표현할까?
            - 정육면체를 2차원으로 표현하는 방법은 무엇일까? -> 6개의 숫자마다 동서남북으로 이동할 때 숫자 배열을 만들자. -> ❌
### 🔗 배운점
1. nextNumMaps처럼 2차원으로 생각하면 안되는 이유
    - 3차원 도형은 바닥 면 하나만 알아서 전체 상태를 알 수 없다. 방향을 모른다.
    - 구르다보면 동서남북을 바라보는 숫자가 달라지기 때문이다.
    - ⭐️ 주사위의 물리적인 6개 면에 들어있는 값 자체를 추적하는 배열이 필요하다.
        - 조금 더 직관적으로 표현하기 위해서 객체 형식이 적합나다.
2. 주사위 굴리기 문제 아이디어
   ```javascript
    let dice = { top: 0, bottom: 0, front: 0, back: 0, left: 0, right: 0 };
   ```
   - 동쪽 굴리기: 앞/뒤 고정. [위, 우, 밑, 좌] = [좌, 위, 우, 밑]
   - 서쪽 굴리기: 앞/뒤 고정. [위, 좌, 밑, 우] = [우, 위, 좌, 밑]
