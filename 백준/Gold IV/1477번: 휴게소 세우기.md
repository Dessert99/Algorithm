[https://www.acmicpc.net/problem/1477](https://www.acmicpc.net/problem/1477)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

let inputIndex = 0;

// N: 현재 휴게소 개수(0~50), M: 추가할 휴게소 개수(1~100), L: 고속도로 길이(100~1000)
const [N, M, L] = input[inputIndex++].split(' ').map(Number);

// 출발점 + 휴게소 + 도로의 끝 위치
let dist = [0]; // 도로 시작점

// 기본 휴게소가 있을 때
if (N !== 0) {
    const arr = input[inputIndex].split(' ').map(Number);
    for (let i = 0; i < N; i++) {
        dist.push(arr[i]);
    }
}
dist.push(L); // 도로의 끝

// 정렬
dist.sort((a, b) => a - b);

// 휴게소가 없는 구간 길이
let start = 1;
let end = L; // 휴게소가 아예 없을 수도 있음

let answer;

while (start <= end) {
    // 확인할 휴게소가 없는 구간 길이
    const mid = Math.floor((start + end) / 2);

    // mid 거리에서 M개의 휴게소를 설치할 수 있는지 확인한다.
    if (checked(mid)) {
        // 일단 저장해놓고, 더 작은 값이 가능한지 확인
        answer = mid;
        end = mid - 1;
    } else {
        // mid를 늘려서 다시
        start = mid + 1;
    }
}

console.log(answer);

// length 거리로 M개의 휴게소를 설치할 수 있는지?
function checked(length) {
    // 필요한 휴게소
    let cnt = 0;

    // 휴게소 반복
    for (let i = 1; i < dist.length; i++) {
        // 휴게소 간격
        const distance = dist[i] - dist[i - 1];

        // 간격 / length = 필요한 휴게소. ⭐️ 나누어 떨어질 때를 대비해서 -1 한다.
        const need = Math.floor((distance - 1) / length);

        cnt += need;
    }

    // 만약 필요한 휴게소 개수를 넘었다면? 불가능하다
    if (cnt > M) {
        return false;
    } else {
        return true;
    }
}
```
### 🔗 풀이
1. 💡 조건 분석
    1. 휴게소 세울 수 있는 조건
        - 무조건 정수 위치
        - 중복 ❌
        - 끝에 ❌
    2. 휴게소는 1번째부터 생긴다.

2. 🤔 ❌ 휴게소 세우는 기준이 어떻게 될까?
    - 일단 현재 휴게소가 없는 구간의 최댓값을 파악한다
    - 그 중간에 휴게소를 설치한다.
    - 다시 휴게소가 없는 구간의 최댓값을 파악한다.
    - 그 중간에 휴게소를 설치한다.
    - M번 반복한다.
    - 이후 휴게소가 없는 구간의 최댓값을 구한다.
    - ❌ 이 방법이 안되는 이유. 길이가 100이고, 2개의 휴게소를 세울 수 있을 때, 내 방법으로 하면 0 25 50 100이 되어서 최댓값이 50이 된다. 하지만 0 33 66 100 으로 3등분하면 33이 최댓값이다.

3. 💡 이분 탐색
    - 일단 휴게소 간 최댓값을 선언한다.
    - 그 거리로 `M`개의 휴게소를 세울 수 있는지 확인한다.
    - 세울 수 있다면 더 짧은 거리로 가능한지 파악한다.

4. 🤔 checked함수 로직
    - 👀 ❌ 방법1) 시뮬레이션 방식: 폐기한다. 예외 조건이 너무 많다.
        1. 첫번째 위치를 기준점으로 설정하고 `length`칸씩 늘려가며, 휴게소가 있는지 확인한다.
        2. 없다면 휴게소를 설치한다. 기준점을 갱신한다.
        3. 있다면 그 휴게소를 기준점으로 설정한다.
        4. `M`번 반복한다.
        5. 반복문이 끝나고, 기준점이 L이상일 경우 `length`길이로 휴게소를 모두 설치할 수 있다.
    - 🤔 구현을 다르게 해보자
        - 우리가 파악해야하는 것은 무엇일까? 모든 휴게소를 설치했을 때, 그들은 모두 length만큼 떨어져 있는가?
        - 👀 ✅ 방법2) 
            1. `restArea`를 순회하며 휴게소 간의 간격을 확인한다.
            2. 그 간격을 `mid`로 나눈 몫이 필요한 휴게소이다.

5. 🤔 `L`길이의 `road`배열이 굳이 필요할까?
    - 매번 복사본을 만들면 메모리 초과 위험이 있다.
    - 그냥 주어진 휴게소 위치 배열만 갖고도 구현할 수 있을 것 같다.
### 🔗 배운점
1. 발상의 전환
   - “어떻게 설치할지” 생각하기보다, “설치가 끝난 뒤 모습”을 생각해보자.
   - 이 문제의 경우 검증 로직을 시뮬레이션으로 구현한다면 예외 조건이 많아서 복잡하다. 이럴 때는 "계산"으로 풀어봐야 한다.
   - 생각의 흐름대로 풀다가 너무 복잡해지면, 방향을 틀어서 완성된 상황을 생각해보자.
