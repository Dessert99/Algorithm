[https://www.acmicpc.net/problem/2110](https://www.acmicpc.net/problem/2110)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

// N: 집의 개수, C: 공유기 개수
const [N, C] = input[0].split(' ').map(Number);

// 공유기 사이 최대 거리
let answer = 0;

// 집의 좌표들
const homes = [];

for (let i = 1; i <= N; i++) {
    homes.push(Number(input[i]));
}

// 정렬
const sortedHomes = homes.sort((a, b) => a - b);

// 최소 거리: 모든 집에 공유기가 있는 경우
let start = 1;

// 최대 거리: 공유기가 2개여서 첫 번째, 마지막 집에만 있는 경우
let end = sortedHomes[N - 1] - sortedHomes[0];

//이분 탐색 시작
while (start <= end) {
    // 중간값: 현재 공유기 간 거리
    const mid = Math.floor((start + end) / 2);

    // 앞에서부터 mid 간격으로 공유기를 설치해본다.
    // 첫 번째에는 무조건 설치
    let count = 1;

    // 이전에 설치했던 집 좌표
    let lastPostition = sortedHomes[0];

    for (let i = 1; i < N; i++) {
        // 현재 집과 이전 집 거리를 계산
        const curPosition = sortedHomes[i];

        const gap = curPosition - lastPostition;

        // 그 거리가 mid보다 크거나 같다면 공유기 설치 가능.
        if (gap >= mid) {
            //공유기 설치
            count++;
            lastPostition = curPosition;
        }
    }

    //  공유기가 남았다면 실패.
    if (C > count) {
        // 공유기 간 거리가 너무 길다. 줄여야 한다.
        end = mid - 1;
    } else {
        // 모든 공유기를 설치했다면 성공

        answer = mid;

        // 거리를 늘려서 다시 시도
        start = mid + 1;
    }
}

console.log(answer);
```
### 🔗 풀이
1. 집의 좌표 배열을 정렬한다. (최대 20만 개)
2. 이분 탐색 기준은 “공유기 사이 거리” 이다.
3. 최소 거리, 최대 거리를 계산한다.
    - 모든 집에 공유기가 있는 경우 최대 거리는 1이다.
    - 공유기가 2개인 경우 처음과 끝을 이어주는 거리가 최대이다.
4. 이분 탐색을 시작한다. (`mid` : 현재 공유기 간 거리)
5. 집 좌표 배열을 순회하며, 이전 집과 현재 집의 거리가 `mid` 이상이라면 공유기를 설치한다.
6. 순회를 마치고, 주어진 공유기 `C`를 모두 설치했다면, 공유기 간 거리를 늘려 재탐색한다. 설치하지 못했다면 거리를 줄이고 재탐색한다.

### 🔗 배운점
1. 이분 탐색을 써야할 근거?
    - 집의 좌표가 최대 10억이다. 순차 탐색을 하며 모든 집을 확인할 경우 시간 초과가 발생한다. **$O(\log N)$** 알고리즘인 이분 탐색이 필수적이다.
