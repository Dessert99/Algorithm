[https://www.acmicpc.net/problem/14500](https://www.acmicpc.net/problem/14500)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

let inputIndex = 0;
// 세로 N, 가로 M  4~500
const [N, M] = input[inputIndex++].split(' ').map(Number);

// 지도
const maps = [];
for (let i = 0; i < N; i++) {
    maps.push(input[inputIndex++].split(' ').map(Number));
}

// 방문 여부 배열
const visited = Array.from({ length: N }, () => Array(M).fill(false));

const dy = [-1, 0, 1, 0];
const dx = [0, 1, 0, -1];

let answer = 0;

// ㅗ 모양을 제외한 나머지 도형
function DFS(y, x, count, sum) {
    // 기저 조건: 폴리오미노 4개
    if (count === 4) {
        // 최댓값 저장
        answer = Math.max(answer, sum);
        return;
    }

    // 기본 조건: 상하좌우를 확인하고 이어져 있는 방향으로 재귀한다.
    for (let i = 0; i < 4; i++) {
        const ny = y + dy[i];
        const nx = x + dx[i];

        // 재귀 조건: 유효한 범위, 방문하지 않은 도형
        if (ny < N && nx < M && ny >= 0 && nx >= 0 && visited[ny][nx] === false) {
            // 방문 표시 후 재귀
            visited[ny][nx] = true;
            DFS(ny, nx, count + 1, sum + maps[ny][nx]);

            // 재귀에서 빠져나오면 방문 표시 취소
            visited[ny][nx] = false;
        }
    }
}

// ㅗ 도형 함수
function shapeT(y, x) {
    let sum = maps[y][x];

    // 상하좌우 저장할 배열
    const tmp = [];

    for (let i = 0; i < 4; i++) {
        const ny = y + dy[i];
        const nx = x + dx[i];

        // 유효한 범위 체크
        if (ny >= 0 && nx >= 0 && ny < N && nx < M) {
            // 유효하다면 값을 모두 더하고 tmp 배열에 저장한다.
            tmp.push(maps[ny][nx]);
            sum += maps[ny][nx];
        }
    }
    // 유효한 값이 4개라면
    if (tmp.length === 4) {
        // 최솟값을 제외한다.
        sum -= Math.min(...tmp);
    }

    // 유효한 값이 2개 이하라면 테트로미노를 만들 수 없다.
    if (tmp.length <= 2) {
        //종료
        return;
    }

    // 3개일 때만 비교
    answer = Math.max(answer, sum);
}

// 순차 탐색하며 검사
for (let y = 0; y < N; y++) {
    for (let x = 0; x < M; x++) {
        // ㅗ 도형 외에 다른 도형 검사 시작
        visited[y][x] = true;
        DFS(y, x, 1, maps[y][x]);
        visited[y][x] = false;

        // ㅗ 도형 검사
        shapeT(y, x);
    }
}
console.log(answer);
```
### 🔗 풀이
1. 💡 시간복잡도  
    - 최대 지도 크기는 25만
		- 깊이마다 상하좌우 중 3방향으로 갈 수 있다. 깊이가 4까지 있으니, 3 3 3
		- 25만 x 27 = 6백만

2. 💡 도형을 돌려가면서 모든 상황을 파악해봐야할까?  
    - 회전, 대칭이 가능하다. 그냥 이어붙인 4개의 도형이 모두 가능하다고 보면 된다.

3. 🤔 모든 경우의 수를 세어봐야할 것 같다. 어떤 방식으로 가능할까?  
    - 제약 조건은 "4개 정사각형이 모두 붙어있어야 한다." 라는 점이다.

4. 👀 방법1. 3개씩 묶기  
    - 나열된 3개의 정사각형을 한묶음으로 본다.
    - 이 묶음과 이어진 주위를 돌며 최댓값을 탐색한다.
    - 패턴은 두 가지이다. 가로로 3열, 세로로 3열.
    문제점 -> 이러면 4번째 테트로미노를 고려할 수 없다.

5. 👀 방법2. 한붓그리기  
    - 지도를 순차 탐색하며, 백트래킹 방식으로 모든 경우의 수를 확인하는 방식이다.
    - 이때, 모든 조합을 계산하는 것이 아니라, "이어져 있는 경우에만 계산한다."
    - "이어져 있다" 라는 것은 어떻게 알 수 있을까? -> BFS 처럼 상하좌우 확인하는 로직을 넣어보자.
    1. 백트래킹. 기저 조건은 깊이가 4일 때.
    2. 기본 조건은 상하좌우를 확인해서 붙어있는 곳만 재귀한다.
    3. ❓ DFS 매개변수로 어떤 정보를 넣어야할까?
        - 상하좌우를 확인하려면 "현재 위치" 정보를 넣어야 한다.

6. ⭐️⭐️ ㅗ모양은 따로 구해야 한다.  
    - 왜? 상하좌우 검사한 뒤 이어져있는 도형일 경우에만 재귀한다. 이렇게 되면 한붓그리기가 되는데, ㅗ는 한붓그리기로 구할 수 없기 때문이다.
    - 구하는 방법이 무엇일까?
        1. 매개변수는 y,x를 받는다.
        2. 현재 위치와 상하좌우 값을 모두 더한다. 조건은 아래와 같다.
        3. 상하좌우 중 범위를 벗어나는 값은 제외한다.
        4. 그 결과 유효한 값이 4개라면 최솟값을 뺀다.
            - 이건 어떻게 판단할까? -> 상하좌우 값을 배열에 저장한 뒤, 배열 길이 가지고 판단한다.
        5. 유효한 값이 3개라면 그냥 더한다.
        6. 유효한 값이 2개라면 패스한다.
        7. answer값을 갱신한다.

### 🔗 배운점
1. 백트래킹(`DFS`) 구현할 때는 “매개변수에 어떤 정보를 넣어야 하는가?”를 항상 생각하자.
    
    ```javascript
    function DFS(y, x, count, sum) {
    		...
    }
    ```
    
    - 이 문제에서는 깊이를 표현할 `count`뿐만 아니라, 누적 합계 정보인 `sum`이 필요하다.
    - 또, 재귀 조건이 “현재 위치에서 붙어있는 도형”이기 때문에, 현재 위치 정보인 `y`, `x` 를 추가해야한다.
2. ㅗ모양을 따로 구해야 하는 이유
    - DFS 는 붙어있는 폴리오미노로만 이동한다. 상하좌우를 탐색하며 유효한 범위에 있는 폴리오미노로 이동하는 방식이다.
    - 이렇게 되면, 폴리오미노는 한붓그리기처럼 연결되어 ㅗ처럼 중간에 다시 돌아가야 그릴 수 있는 도형은 탐색하지 못한다.
    - 그래서 ㅗ모양만 탐색할 수 있는 함수를 따로 만들어줘야 한다.
