[https://www.acmicpc.net/problem/7662](https://www.acmicpc.net/problem/7662)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

// 최소힙
class MinHeap {
    constructor() {
        this.heap = [];
    }

    // 유틸
    getParentIndex(curIndex) {
        return Math.floor((curIndex - 1) / 2);
    }
    getLeftChildIndex(curIndex) {
        return curIndex * 2 + 1;
    }
    getRightChildIndex(curIndex) {
        return curIndex * 2 + 2;
    }

    swap(i1, i2) {
        [this.heap[i1], this.heap[i2]] = [this.heap[i2], this.heap[i1]];
    }

    // 넣기
    insert(value) {
        this.heap.push(value);
        this.heapifyUp();
    }

    // 정렬
    heapifyUp() {
        // 들어온 값 인덱스
        let curIndex = this.heap.length - 1;

        // 제자리를 찾아갈 때까지 반복한다.
        // 기본 종료 조건: curIndex가 0일 때
        while (curIndex > 0) {
            // 부모 인덱스 파악
            const parentIndex = this.getParentIndex(curIndex);

            // 종료 조건: 현재 값이 부모 이상일 때
            if (this.heap[parentIndex] <= this.heap[curIndex]) {
                // 최소힙은 인덱스가 작아질수록 값이 작아진다.
                break;
            }

            // 아직 현재 값이 부모보다 작다면 올려야 한다.
            this.swap(parentIndex, curIndex);
            curIndex = parentIndex;
        }
    }

    // 빼기
    extractMin() {
        // 힙이 비었다면 null 반환
        if (this.heap.length === 0) {
            return null;
        }
        // 힙에 값이 하나라도 그게 최솟값이다.
        if (this.heap.length === 1) {
            return this.heap.pop();
        }

        // 최솟값 빼놓기 (맨 앞에 있는 요소)
        const min = this.heap[0];

        // 전체적으로 정렬하기 위해서 맨 밑 요소를 루트로 끌어당긴다.
        this.heap[0] = this.heap.pop();

        // 정렬
        this.heapifyDown();

        // 최솟값 반환
        return min;
    }

    //정렬
    heapifyDown() {
        // 정렬 대상 인덱스. (초기값은 아까 루트로 올렸던 맨 마지막 값 인덱스)
        let curIndex = 0;

        // 최소힙 길이
        const length = this.heap.length;

        // 제자리를 찾아갈 때까지 반복
        while (true) {
            // 일단 현재 인덱스가 최솟값이라고 가정. 이후 왼쪽, 오른쪽 자식과 비교하며 결정한다.
            let minIndex = curIndex;
            // 왼쪽 자식 인덱스
            const leftChildIndex = this.getLeftChildIndex(curIndex);
            // 오른쪽 자식 인덱스
            const rightChildIndex = this.getRightChildIndex(curIndex);

            // 왼쪽 자식과 비교. 이때 배열 참조 에러를 피하려면, 인덱스가 유효한지 확인해야 한다.
            if (leftChildIndex < length && this.heap[leftChildIndex] < this.heap[minIndex]) {
                // 왼쪽 자식이 최솟값보다 작다면, 최솟값 인덱스를 바꾼다.
                minIndex = leftChildIndex;
            }

            // 오른쪽도 동일하게 비교한다.
            if (rightChildIndex < length && this.heap[rightChildIndex] < this.heap[minIndex]) {
                minIndex = rightChildIndex;
            }

            // 비교 이후에도 최솟값 인덱스가 바뀌지 않았다면 지금 위치가 적절하다는 의미이므로, 반복문을 종료한다.
            if (minIndex === curIndex) {
                break;
            }

            // 반복문이 종료되지 않았다면, 위치 조정이 필요하다는 의미이다.
            this.swap(minIndex, curIndex);
            curIndex = minIndex;
        }
    }
}

// 최대힙
class MaxHeap {
    constructor() {
        this.heap = [];
    }
    // 유틸
    getParentIndex(curIndex) {
        return Math.floor((curIndex - 1) / 2);
    }
    getLeftChildIndex(curIndex) {
        return curIndex * 2 + 1;
    }
    getRightChildIndex(curIndex) {
        return curIndex * 2 + 2;
    }

    swap(i1, i2) {
        [this.heap[i1], this.heap[i2]] = [this.heap[i2], this.heap[i1]];
    }
    // 넣기
    insert(value) {
        this.heap.push(value);
        this.heapifyUp();
    }

    // 정렬
    heapifyUp() {
        // 들어온 값 인덱스
        let curIndex = this.heap.length - 1;

        // 제자리를 찾아갈 때까지 반복한다.
        // 기본 종료 조건: curIndex가 0일 때
        while (curIndex > 0) {
            // 부모 인덱스 파악
            const parentIndex = this.getParentIndex(curIndex);

            // 종료 조건: 현재 값이 부모 이하일 때
            if (this.heap[parentIndex] >= this.heap[curIndex]) {
                // 최대힙은 인덱스가 작아질수록 값이 커진다.
                break;
            }

            // 아직 현재 값이 부모보다 크다면 올려야 한다.
            this.swap(parentIndex, curIndex);
            curIndex = parentIndex;
        }
    }

    // 빼기
    extractMax() {
        // 힙이 비었다면 null 반환
        if (this.heap.length === 0) {
            return null;
        }
        // 힙에 값이 하나라도 그게 최솟값이다.
        if (this.heap.length === 1) {
            return this.heap.pop();
        }

        // 최댓값 빼놓기 (맨 앞에 있는 요소)
        const max = this.heap[0];

        // 전체적으로 정렬하기 위해서 맨 밑 요소를 루트로 끌어당긴다.
        this.heap[0] = this.heap.pop();

        // 정렬
        this.heapifyDown();

        // 최솟값 반환
        return max;
    }

    //정렬
    heapifyDown() {
        // 정렬 대상 인덱스. (초기값은 아까 루트로 올렸던 맨 마지막 값 인덱스)
        let curIndex = 0;

        // 최소힙 길이
        const length = this.heap.length;

        // 제자리를 찾아갈 때까지 반복
        while (true) {
            // 일단 현재 인덱스가 최댓값이라고 가정. 이후 왼쪽, 오른쪽 자식과 비교하며 결정한다.
            let maxIndex = curIndex;
            // 왼쪽 자식 인덱스
            const leftChildIndex = this.getLeftChildIndex(curIndex);
            // 오른쪽 자식 인덱스
            const rightChildIndex = this.getRightChildIndex(curIndex);

            // 왼쪽 자식과 비교. 이때 배열 참조 에러를 피하려면, 인덱스가 유효한지 확인해야 한다.
            if (leftChildIndex < length && this.heap[leftChildIndex] > this.heap[maxIndex]) {
                // 왼쪽 자식이 최솟값보다 크다면, 최댓값 인덱스를 바꾼다.
                maxIndex = leftChildIndex;
            }

            // 오른쪽도 동일하게 비교한다.
            if (rightChildIndex < length && this.heap[rightChildIndex] > this.heap[maxIndex]) {
                maxIndex = rightChildIndex;
            }

            // 비교 이후에도 최댓값 인덱스가 바뀌지 않았다면 지금 위치가 적절하다는 의미이므로, 반복문을 종료한다.
            if (maxIndex === curIndex) {
                break;
            }

            // 반복문이 종료되지 않았다면, 위치 조정이 필요하다는 의미이다.
            this.swap(maxIndex, curIndex);
            curIndex = maxIndex;
        }
    }
}

let inputIndex = 0;

// 입력 데이터 수
const T = Number(input[inputIndex++]);

let answer = [];

for (let t = 0; t < T; t++) {
    // Q에 적용할 연산의 개수 (~백만)
    const K = Number(input[inputIndex++]);

    // 최소힙
    const minHeap = new MinHeap();
    // 최대힙
    const maxHeap = new MaxHeap();

    // 해시맵
    const map = new Map();

    // 연산 시작
    for (let k = 0; k < K; k++) {
        const line = input[inputIndex++];

        const operation = line[0];
        const n = Number(line.slice(2));

        // I 연산일 때
        if (operation === 'I') {
            //
            map.set(n, map.has(n) ? map.get(n) + 1 : 1);
            // 양쪽 힙에 저장
            minHeap.insert(n);
            maxHeap.insert(n);
        }

        // D 연산일 때
        if (operation === 'D') {
            // n이 1일 때: 최댓값 삭제
            if (n === 1) {
                // 유효한 데이터를 꺼낼 때까지 반복한다.
                while (maxHeap.heap.length > 0) {
                    const max = maxHeap.extractMax();
                    // 해당 숫자를 1개 이상 보유하고 있을 때
                    if (map.get(max) > 0) {
                        // 값을 내림
                        map.set(max, map.get(max) - 1);

                        // 반복문 종료
                        break;
                    }
                }
            }

            // n이 -1일 때: 최솟값 삭제
            if (n === -1) {
                // 유효한 데이터를 꺼낼 때까지 반복한다.
                while (minHeap.heap.length > 0) {
                    const min = minHeap.extractMin();
                    // 해당 숫자를 1개 이상 보유하고 있을 때
                    if (map.get(min) > 0) {
                        // 값을 내림
                        map.set(min, map.get(min) - 1);

                        // 반복문 종료
                        break;
                    }
                }
            }
        }
    }

    // 연산이 끝나고 큐에 있는 최댓값, 최솟값 출력
    let max;
    let min;

    // 최대힙에 유령 데이터 지우기
    // 조건1) 힙에 값이 있어야 하고, 조건2) map에서 조회한 값이 0이어야 함(유령 데이터)
    while (maxHeap.heap.length > 0 && map.get(maxHeap.heap[0]) === 0) {
        maxHeap.extractMax();
    }
    // 청소 이후에 값이 있다면 최댓값
    if (maxHeap.heap.length > 0) {
        max = maxHeap.heap[0]; // 이때 최소힙 계산에 필요하기 때문에 extract하면 안된다.
    }

    while (minHeap.heap.length > 0 && map.get(minHeap.heap[0]) === 0) {
        minHeap.extractMin();
    }
    if (minHeap.heap.length > 0) {
        min = minHeap.heap[0];
    }

    if (min === undefined || max === undefined) {
        answer.push('EMPTY');
    } else {
        answer.push(`${max} ${min}`);
    }
}

console.log(answer.join('\n'));
```
### 🔗 풀이
1. 💡 이중 우선순위 큐
    - 전형적인 큐와 차이점
        - 데이터를 삭제할 때 연산(`operation`) 명령에 따라 우선순위가 가장 높은 데이터 또는 가장 낮은 데이터 중 하나를 삭제하는 점
    - 두 가지 연산
        1. 하나는 데이터를 삽입하는 연산 : I
        2. 다른 하나는 데이터를 삭제하는 연산 : D
            a. 하나는 우선순위가 가장 높은 것을 삭제하기 위한 것
            b. 다른 하나는 우선순위가 가장 낮은 것을 삭제하기 위한 것

2. 💡 참고 조건
    1. 동일한 정수가 삽입될 수 있음을 참고
    2. 최댓값(최솟값)을 삭제하는 연산에서 최댓값(최솟값)이 둘 이상인 경우, 하나만 삭제됨을 유념
    3. 만약 Q가 비어있는데 적용할 연산이 ‘D’라면 이 연산은 무시해도 좋다.

3. 최소힙, 최대힙 두 가지 우선순위 큐를 만든다. 이때, 해시맵을 사용하여 두 큐를 동기화시킨다.

### 🔗 배운점
1. 🤔 문제에서 말하는 "표준 입력/출력 이란 뭘까?"
    - 표준 입력: 문제 데이터 받기 (`fs.readFileSync` 사용)
    - 표준 출력: 정답 데이터 주기 (`console.log` 사용)

2. 🤔 최소힙, 최대힙을 각각 만든다?
    - 각각 만든다고 해도, 데이터가 삽입/삭제 될 때 결과를 공유해야한다.
    - 최소힙에서 10을 뺏을 때, 최대힙에서 10이 어디에 있는지 몰라서 뺄 수 없다. -> 값을 공유하는 공간이 필요하다.
        - 👀 방법1) 값을 공유하는 공간: `Map`
            1. `Map`을 만든다.
            2. 힙에 넣기 전, `{ key: 숫자, value: 개수 }` 형식으로 `Map`에 저장한다.
            3. 최소힙, 최대힙 두 곳 모두 새로운 값을 넣는다.
            4. 만약 최소힙, 최대힙에서 제외했다면? Map에서 그 숫자의 개수를 줄인다.
            5. 이때, 빼기 전에 루트값이 "아직 존재하는 값"인지 `Map`에서 확인한다.
            6. 만약, `Map`에 존재하지 않는다면 다른 힙에서 이미 뺀 데이터이므로 한 번 더 `extract()`연산을 실행한다

3. 🤔 마지막에 힙에 남아있는 최댓값, 최솟값을 확인할 때도 map을 확인해야 한다?
    - 모든 연산이 끝났더라도, 최대힙-최소힙은 동기화가 안되었을 수도 있다.
    - 마지막 출력하기 전에 유령 데이터를 전부 제거해야 한다.
    - 👀 방법1)
        1. 최대힙부터 지워준다. 이때, 힙에 값이 있어야 한다. 왜?
        2. 유령 데이터 조건은 `map`값이 0인 경우이다.
        3. 청소 이후에도 힙에 값이 있다면 유효한 값이다. `max`
        4. 최소힙도 동일하게 적용한다.

4. ⭐️ 메모리 초과 해결
    - 아마 `const line = input[inputIndex++].split(' ');` 이 부분에서 계속 새로운 배열이 생성되어 메모리 초과가 발생한 것 같다.
        - 💡 `split()`연산을 없애고, `slice()`로 잘라낸다.
