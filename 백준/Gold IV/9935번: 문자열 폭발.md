[https://www.acmicpc.net/problem/9935](https://www.acmicpc.net/problem/9935)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

let inputIndex = 0;

// 문자열: 1~백만
const st = input[inputIndex++];

// 폭발 문자열: 1~36
const bomb = input[inputIndex];

// 폭탄 길이
const bomLength = bomb.length;

const stack = [];

// 문자열 순회
for (let i = 0; i < st.length; i++) {
    // 일단 스택에 넣는다.
    stack.push(st[i]);

    // 폭탄의 마지막 문자와 같다면
    if (st[i] === bomb[bomLength - 1]) {
        // 스택 끝부분과 폭탄이 같은지 확인
        if (stack.slice(stack.length - bomLength).join('') === bomb) {
            // 같다면 다 뺀다.
            for (let j = 0; j < bomLength; j++) {
                stack.pop();
            }
        }
    }
}
console.log(stack.length === 0 ? 'FRULA' : stack.join(''));
```
### 🔗 풀이
1. 💡 조건 해석
    1. 남아있는 문자가 없는 경우가 있다. -> CC44 인 경우, 폭탄이 C4일 경우 다 터진다.
    2. 폭발 문자열은 같은 문자를 두 개 이상 포함하지 않는다. -> CC 이런거 아님. c3, d5 이렇게 다른 것들로 만들어짐.
    3. 입력값이 무척 크다.(백만) -> 무조건 O(n)으로 풀어야 한다.

2. 🤔 단순히 반복문을 돌리면서 replace로 없애는 방법은 어떨까? -> ❌
    - 시간복잡도를 구해보자. replace는 O(N)이다. 최대 백만 번 연산한다.
    - 최악의 경우, 폭탄은 길이가 1이고, 백만 번 x 백만 번 연산해야 한다.
    - 게다가 replace는 새로운 문자열을 생성해서 메모리 공간을 잡아먹는다.

3. 🤔 스택으로 풀어볼까?
    - 일단 폭탄의 최대 길이는 36이다. 문자열과 이중 반복문으로 돌려도, 천만 번 연산해서 안전한다.
    - 꼬리부터 확인해보자.

4. 👀 방법1)
    1. 스택에 넣는다.
    2. 넣은 문자열이 폭탄의 끝과 같은지 확인한다.
    3. 폭탄과 달라질떄까지 뺀다.
### 🔗 배운점
1. 스택 문제는 "뒤에서부터 생각"해보자.
   - 스택 자료구조의 특징을 고려해서 모든 발상을 뒤에서부터 생각해본다.
