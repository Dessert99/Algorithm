[https://www.acmicpc.net/problem/9663](https://www.acmicpc.net/problem/9663)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

let answer = 0;

// 1~14
const N = Number(input[0]);

// 보드: board[행] = 열
const board = new Array(N).fill(0);

function dfs(y) {
    // 기저 조건: 모든 행을 볼 때까지
    if (y === N) {
        answer++;
        return;
    }

    // 기본 조건: 퀸을 모든 열에 놓아본다.
    for (let x = 0; x < N; x++) {
        // 퀸 놓음: 현재 행에 열을 저장
        board[y] = x;

        // 유효성 검사
        if (isValid(y)) {
            // 놓을 수 있다면 재귀
            dfs(y + 1); // 다음 행 탐색
        }
    }
}

function isValid(y) {
    // 0~바로 윗 행까지 탐색
    for (let prevY = 0; prevY < y; prevY++) {
        // 만약 같은 열에 퀸이 있다면
        if (board[prevY] === board[y]) {
            return false;
        }
        // 만약 같은 대각선에 퀸이 있다면
        if (Math.abs(prevY - y) === Math.abs(board[prevY] - board[y])) {
            return false;
        }
    }
    return true;
}

dfs(0);

console.log(answer);
```
### 🔗 풀이
1. 🤔 단순 true/false로 체크하면 안되는 이유
    - 백트래킹 특성상 재귀에서 빠져나올 때, true -> false로 바꾼다. 하지만 어떤 칸은 퀸의 영향이 겹칠 수가 있다. 이 경우 그냥 false로 바꿔버리면 문제가 생긴다.
    - 그래서 보드에서 공간이 겹치는 곳이 생길 때, 단순값이 아닌 count로 값을 올려줘야 한다.

2. 🤔 2차원 배열을 1차원으로 압축한다.
    - 중복 체킹 방식을 도입하면 2차원 배열은 관리하기 힘들어진다. 1차원으로 압축해서 사용한다.
    - 1차원으로 사용하는 방법 -> board[행] = 열

3. 🤔 백트래킹 매개변수를 퀸 개수가 아닌, 행으로 해야 한다.
    - 이건 배열을 1차원으로 압축했기 떄문에 필수적이다.
    - 어짜피 퀸은 행마다 하나씩 놓을 수 있기 떄문에 이렇게 해도 좋다.

4. 🤔 같은 대각선에 있으려면?
    - 행의 변화량의 절댓값 === 열의 변화량의 절댓값 

### 🔗 배운점
1. 왜 `board`를 1차원으로(`board[행] = 열`) 저장해야 하는가?
    - `N`이 최대 14이다. 2차원 배열을 만들고 퀸을 놓을 때마다 8방향으로 방문 표시를 해야 한다면 시간 초과가 날 수 있다.
    - 퀸은 행, 열에 각각 하나씩 놓을 수 있다. 한 행에 퀸을 하나밖에 놓을 수 없다. 우리가 알아야 할 정보는 “n번째 행의 퀸이 몇 번째 열에 있는가”만 기억하면 된다.
2. 왜 `dfs` 매개변수로 퀸 개수가 아닌, 행 번호를 넣는가?
    - 앞선 사고 과정으로 우리는 행에 최대 퀸 한 개를 놓을 수 있다는 사실을 깨달았다. 어차피 행, 열, 퀸의 개수가 전부 `N`으로 동일하다.
    - 우리가 추적해야 할 정보는 “몇 번째 줄에 퀸을 놓을 차례인가?”이기 때문에 매개변수는 현재 탐색 중인 행이어야 한다.
3. 왜 유효성 검사 전에 `board[y] = x`를 먼저 놓고 시작하는가?
    - 해당 코드의 반복문은 “현재 행에서 열만 바꿔가면서 퀸을 놓아보는 것”이다.
    - 일단 현재 행(y) 왼쪽부터 차례대로 퀸을 놓아가며, `isValid(y)` 으로 유효한 위치인지 파악한다.
    - 뒤에서 다시 언급하겠지만, 이 로직이 백트래킹의 “원상복구” 기능을 대신한다. 만약 `isValid(y)`를 통과하지 못한다면 재귀하는 것이 아니라, `x+1` 다음 열로 넘어가며 덮어쓰기 때문이다.
4. 왜 유효성 검사(`isValid`)를 하는가?
    - 1차원 배열로 바꾸면서 1행 1퀸이 보장된다. 하지만 열과 대각선에서 생기는 충돌은 아직 확인해야 한다. `isValid(y)` 함수가 그 역할이다.
5. 왜 재귀를 빠져나올 때 "원상복구(`visited = false` 등)"가 없는가?
    - 아까 잠시 언급했지만, 현재 로직에서 유효성 검사를 통과하지 못하면 자연스럽게 다음 열로 넘어간다. 이때, `board[y] = x` 로직은 이전 퀸 위치를 덮어쓰기 때문에 원상복구 로직이 필요없다.
6. 왜 유효성 검사에서 '바로 직전 행(`prevY < y`)'까지만 검사하는가?
    - 지금 퀸을 놓는 방향이 위→아래 이다.
