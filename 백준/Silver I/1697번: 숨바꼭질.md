[https://www.acmicpc.net/problem/1697](https://www.acmicpc.net/problem/1697)

```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim();

// N : 수빈 위치  K : 동생 위치
const [N, K] = input.split(' ').map(Number);

// 방문 여부 표시 배열
const visited = Array.from({ length: 100001 }, () => false);

// 큐:  [cur, time]
const queue = [];

// 시작점은 수빈 위치, 0초부터 시작한다.
queue.push([N, 0]);
visited[N] = true;

// BFS
while (queue.length > 0) {
    const [cur, time] = queue.shift();

    // 종료 조건: 현재 위치가 동생 위치라면
    if (cur === K) {
        console.log(time);
        process.exit(); // 결과 찾으면 종료
    }

    // +1 이동
    const plus_1 = cur + 1;
    if (plus_1 <= 100000 && visited[plus_1] === false) {
        visited[plus_1] = true;
        queue.push([plus_1, time + 1]);
    }

    // -1 이동
    const minus_1 = cur - 1;
    if (minus_1 >= 0 && visited[minus_1] === false) {
        visited[minus_1] = true;
        queue.push([minus_1, time + 1]);
    }

    // *2 이동
    const multi_2 = cur * 2;
    if (multi_2 <= 100000 && visited[multi_2] === false) {
        visited[multi_2] = true;
        queue.push([multi_2, time + 1]);
    }
}
```
### 배운점
1. `cur-1`, `cur+1`, `cur*2` 세 가지 경우의 수는 서로 다른 세계관이 아니다.
   - 어짜피 이 문제는 "최단 거리"를 구하는 문제이기 때문에 모든 경우를 알아야 할 필요는 없다. 방문한 위치를 거친다는 것은 이미 최단 거리가 아니다.
2. 방문 여부 배열이 있어야 하는 이유
   - 방문 여부를 파악하지 않으면, `cur-1` -> `cur+1` 무한 루프가 발생한다.
3. 코드 리팩토링
   ```javascript
   for (const next of [cur - 1, cur + 1, cur * 2]) {
    
    // 공통 검사 로직 (범위 체크 && 방문 여부 체크)
    if (next >= 0 && next <= 100000 && !visited[next]) {
        visited[next] = true;
        queue.push([next, time + 1]);
      }
    }  
   ```
   - 3가지 이동 경우의 수를 한 번에 처리할 수 있다.
