[https://www.acmicpc.net/problem/7576](https://www.acmicpc.net/problem/7576)

```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

// 큐 생성
class Queue {
    constructor() {
        this.store = [];
        this.front = 0;
        this.rear = 0;
    }

    size() {
        return this.rear - this.front;
    }

    enqueue(value) {
        this.store[this.rear] = value;
        this.rear++;
    }

    dequeue() {
        const value = this.store[this.front];
        this.front++;
        return value;
    }
}

// M: 가로 칸 수, N: 세로 칸 수
const [M, N] = input[0].split(' ').map(Number);

// 상자 만들기
const maps = [];
for (let i = 1; i < input.length; i++) {
    maps.push(input[i].split(' ').map(Number));
}

// 큐
const q = new Queue();

const dx = [-1, 0, 1, 0];
const dy = [0, 1, 0, -1];

// 익은 토마토들 큐에 넣기
for (let y = 0; y < N; y++) {
    for (let x = 0; x < M; x++) {
        if (maps[y][x] === 1) {
            q.enqueue([y, x]);
        }
    }
}

// 큐가 빌 때까지 반복문
while (q.size() > 0) {
    // 토마토를 꺼낸다.
    const [curY, curX] = q.dequeue();

    // 인접한 토마토를 확인한다.
    for (let i = 0; i < 4; i++) {
        const ny = dy[i] + curY;
        const nx = dx[i] + curX;

        // 큐에 넣는 조건 1) 유효한 범위 2) 익지 않은 토마토
        if (ny >= 0 && nx >= 0 && ny < N && nx < M && maps[ny][nx] === 0) {
            // 큐에 넣기
            q.enqueue([ny, nx]);

            // 시간 카운팅
            maps[ny][nx] = maps[curY][curX] + 1;
        }
    }
}

console.log(maps);
// 평탄화
const flat = maps.flatMap((i) => i);

// 0이 있다면 -1, 없다면 가장 큰 값에서 1뺀 값이 최소 일수
if (flat.some((i) => i === 0)) {
    answer = -1;
} else {
    answer = Math.max(...flat) - 1;
}

console.log(answer);
```
### 🔗 문제 풀이 
1. 준비물
    - 큐 생성 (효율성을 위해서)
    - 토마토 상자 만들기 `maps` 배열
2. 큐에 최초 익은 토마토들 위치를 넣는다.
3. 큐가 빌 때까지 반복한다.
4. 인접한 토마토를 확인한 뒤, 현재 위치에서 +1 시간을 더하고 큐에 넣는다.
5. 반복문이 종료되었을 때, `maps`에서 가장 큰 수에서 1을 뺀 값이 모든 토마토가 익는 최소 일수이다. 만약 0이 있다면 -1을 출력한다.

### 🔗 배운점
1. 시간 복잡도를 고려해 큐(Queue)를 직접 구현하자.
   - 자바스크립트의 shift()는 $O(N)$이라 연산 비용이 비싸다. 데이터가 최대 100만 개까지 늘어날 수 있는 이번 문제에서 shift()를 쓰면 시간 초과가 발생한다. 큐를 직접 구현하면 $O(1)$로 맨 앞 원소를 효율적으로 처리할 수 있다.
2. 별도의 방문 배열(visited)이 꼭 필요한지 고민하자.
   - 이번 문제에서는 maps[ny][nx] === 0 조건으로 방문 여부를 확인할 수 있어 굳이 visited 배열을 만들 필요가 없다. 또한, 경과 시간도 maps에 직접 기록하면 되므로 시간 체크용 배열도 생략 가능하다. 기존 배열을 활용해 메모리를 아끼자.
3. ⭐️ 토마토가 언제 익었는지 `maps`배열에 기록한다.
    - `answer++`해야하는 주기를 파악하기 어렵기 때문에, `maps`배열에 숫자를 올리며, 해당 위치의 토마토가 언제 익었는지 시간을 기록한다.
    - 이로써 따로 시간 배열을 만들 필요도 없고, 최소 일수를 셀 타이밍을 생각하지 않아도 된다.
