[https://www.acmicpc.net/problem/1717](https://www.acmicpc.net/problem/1717)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

let inputIndex = 0;

//n: n+1개 집합 (1~백만),  m: 연산의 개수(1~십만)
const [n, m] = input[inputIndex++].split(' ').map(Number);

// 루트인 번호: 자기 번호를 가리키는 번호
const parent = Array.from({ length: n + 1 }, (_, idx) => idx);

const answer = [];

for (let i = 0; i < m; i++) {
    // 연산
    const [op, a, b] = input[inputIndex++].split(' ').map(Number);

    // 유니온
    if (op === 0) {
        // 두 집합을 합친다.
        uni(a, b);
    }

    // 파인트
    if (op === 1) {
        // a가 b집합에 확인되어 있는가? -> 둘의 루트가 동일한가?
        const isSame = find(a) === find(b); // 경로 압축이 안되었을 수도 있어서 꼭 find()를 호출해야 한다.
        answer.push(isSame ? 'YES' : 'NO');
    }
}

function find(x) {
    let root = x;

    // 루트 찾기
    while (parent[root] !== root) {
        root = parent[root];
    }

    // 경로 압축 -> 거쳐온 모든 노드의 부모를 루트로 갱신
    let curr = x;
    while (curr !== root) {
        let next = parent[curr]; // 다음으로 이동할 원래 루트 기억해두기
        parent[curr] = root; // 내 부모를 루트로 다이렉트 갱신!
        curr = next; // 한 칸 위로 이동
    }

    return root; // 최종 루트 반환
}

function uni(a, b) {
    const rootA = find(a);
    const rootB = find(b);

    if (rootA !== rootB) {
        parent[rootB] = rootA;
    }
}

console.log(answer.join('\n'));
```
### 🔗 풀이
1. 🤔 두 수의 입력값이 동일해도 괜찮은 이유는?
    -  if (rootA !== rootB) 조건문에서 걸러진다.
### 🔗 배운점
1. 유니온 파인드
    > 여러 노드가 존재할 때 어떤 두 개의 노드를 같은 집합으로 묶어 주고, 어떤 두 노드가 같은 집합에 있는지 확인하는 알고리즘
    > 
    - **Union:** 서로 다른 두 개의 집합을 하나의 집합으로 병합하는 연산을 말한다. 이 자료구조에서는 상호 배타적 집합만을 다루므로 Union 연산은 합집한 연산과 같다.
    - **Find:** 하나읜 원소가 어떤 집합에 속해있는지를 판단한다.
    
    ### 🔗 외워라 유니온 파인드
    
    ```jsx
    // 1. 초기화: 처음엔 모두가 자기 자신을 보스로 가짐
    // 예: parent[3] = 3 (3번의 보스는 3번)
    const parent = Array.from({ length: N + 1 }, (_, i) => i);
    
    // 2. Find (경로 압축 적용 ⭐️) : 루트를 찾는 함수. ⭐️ JS 런타임 에러를 피하기 위해 while사용
    function find(x) {
    	 let root = x;
    	 
    	 // 루트 찾기
    	 while (parent[root] !== root) {
    			 root = parent[root];
    	 }
    	 
    	 // 경로 압축 -> 거쳐온 모든 노드의 부모를 루트로 갱신
    	 let curr= x;
    	 while (curr !== root) {
            let next = parent[curr]; // 다음으로 이동할 원래 루트 기억해두기
            parent[curr] = root;     // 내 부모를 루트로 다이렉트 갱신!
            curr = next;             // 한 칸 위로 이동
        }
        
        return root; // 최종 루트 반환
    }
    
    // 3. Union (복잡한 랭크 계산 싹 빼고 그냥 무지성 합치기)
    function union(u, v) {
        const rootU = find(u);
        const rootV = find(v);
        
        // 루트가 다르면, 그냥 한쪽을 다른 쪽에 쿨하게 붙여버림
        if (rootU !== rootV) {
            parent[rootV] = rootU; // V의 보스를 U로 변경
        }
    }
    ```
    
    1. 초기 상태
        
        ```jsx
        const parent = [0, 1, 2, 3, 4, 5]
        ```
        
        - `parent[1] = 1`  1번 루트는 1번이다.
        - `parent[2] = 2` 2번 루트는 2번이다. 이하 동일
    2. `union(1, 2)`  실행
        - 두 수의 루트 찾기
            - `find(1)`은 `1`을 반환, `find(2)`는 `2`를 반환한다.
        - 두 루트가 다르니, 2번이 1번 밑으로 들어간다. `parent[2] = 1`
        - 배열 변화
            
            ```jsx
            // const parent = [0, 1, 2, 3, 4, 5]
            const parent = [0, 1, 1, 3, 4, 5] 
            ```
            
        - 현재 트리
            
            ```
            1
            |
            2
            ```
            
    3. `union(3, 4)`  실행
        - 두 수의 루트 찾기
            - `find(3)`은 `3` 를 반환,  `find(4)`는 `4` 를 반환한다.
        - 두 루트가 다르니, 4번이 3번 밑으로 들어간다. `parent[4] = 3`
        - 현재 배열
            
            ```jsx
            //const parent = [0, 1, 1, 3, 4, 5] 
            const parent = [0, 1, 1, 3, 3, 5]
            ```
            
        - 현재 트리
            
            ```
            1       3
            |       |
            2       4
            ```
            
    4. `union(2, 4)` 실행
        - 두 수의 루트 찾기
            - `find(2)` 실행: 2번의 루트는 1번이고, 1번의 루트는 1
            - `find(4)` 실행: 4번의 루트는 3번이고, 3번의 루트는 3
            - 두 그룹의 진짜 루트는 각각 1번과 3번이다. 따라서 `parent[3] = 1`이 된다. (3번 루트가 1번 루트 밑으로 들어간다.)
        - 현재 배열
            
            ```jsx
            //const parent = [0, 1, 1, 3, 3, 5]
            const parent = [0, 1, 1, 1, 3, 5]
            ```
            
            - ⭐️ 아직 경로 압축이 적용되지 않았다. 여전히 `parent[4] = 3` 이다.
        - 현재 트리
            
            ```
                  1
                 / \
                2   3
                    |
                    4
            ```
            
    5. 경로 압축: `find(4)` 단독 실행
        - 2번, 4번을 합치기 위해 4번의 루트를 찾는 로직이 실행되었었다.
        - 배열이 바뀌는 과정
            1. `find(4)` 호출
                - `parent[4] = 3` 이다. 자신의 번호를 갖지 않았으니 루트가 아니다.
                - `find(3)` 호출한다.
            2. `find(3)` 호출
                - `parent[3] = 1`이다. 여전히 자신의 번호를 갖지 않았으니 루트가 아니다.
                - `find(1)` 호출한다.
            3. `find(1)` 호출
                - `parent[1] = 1`이다. 루트를 발견했다.
                - 이제 루트인 1을 반환한다.
            4. 리턴하면서 덮어쓰기
                - `parent[3] = 1`로 덮어쓴다. 원래 1이긴 했다.
                - `parent[4] = 1`로 덮어쓴다. 3에서 1로 바뀌었다. 직속 부모가 아닌, 루트값으로 바뀌었다.
        - 현재 배열
            
            ```jsx
            //const parent = [0, 1, 1, 1, 3, 5]
            const parent = [0, 1, 1, 1, 1, 5]
            ```
            
            - `parent[4] = 1` 로 바뀌었다.
        - 현재 트리
            
            ```
                  1
                 /|\
                2 3 4
            ```
            
            - 트리가 납작해졌다.
        
    
    ---
    
    ### 🔗 경로 압축 쓰면 좋은 점
    
    - 최악의 경우 트리가 일자로 만들어지는데, 그걸 방지한다.
    - 나중에 `find()`할 때 효율적이다.
