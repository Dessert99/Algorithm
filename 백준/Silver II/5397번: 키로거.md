[https://www.acmicpc.net/problem/5397](https://www.acmicpc.net/problem/5397)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

let inputIndex = 0;

// 테스트 케이스
const L = Number(input[inputIndex++]);

const answer = [];

for (let i = 0; i < L; i++) {
    // 비밀번호
    const password = input[inputIndex++];

    // 커서 왼쪽
    const left = [];
    // 커서 오른쪽 (거꾸로 되어 있다고 보면 된다.)
    const right = [];

    for (const s of password) {
        // 만약 - 를 만나면 커서 왼쪽 문자열을 뺀다.
        switch (s) {
            case '-':
                left.pop();
                break;

            // 커서 왼쪽으로 움직이기
            case '<':
                // 단, 요소가 있을 경우에만
                if (left.length > 0) {
                    right.push(left.pop());
                }
                break;

            // 커서 오른쪽으로 움직이기
            case '>':
                if (right.length > 0) {
                    left.push(right.pop());
                }
                break;
            // 문자열
            default:
                left.push(s);
                break;
        }
    }

    answer.push(left.join('').concat(right.reverse().join('')));
}
console.log(answer.join('\n'));
```
### 🔗 풀이
1. 🤔 커서 구현
    - 인덱스라고 생각하자 -> ❌
    - 맨 앞/뒷부분일 때는 움직이지 않는다.

2. 🤔 비밀번호 순회하면서 해야할 일
    1. '<'를 만나면
        - 커서를 왼쪽으로 움직인다 -> left 마지막 요소를 right으로 이동한다.
        - right.push() left.pop()
    2. '>'를 만나면
        - 커서를 오른쪽으로 움직인다 -> right마지막 요소를 left로 이동한다.
    3. '-'를 만나면
        - left스택의 마지막 요소를 뺀다. pop()
    4. 문자열을 만나면
        - left스택에 넣는다.
### 🔗 배운점
1. 이 문제에서 포인트는 커서를 움직이는게 아니다.
   - 커서 움직임에 따라 문자열이나 배열을 새롭게 만들면 메모리, 시간 초과가 무조건 발생한다.
   - 이럴 때 필요한 자료구조를 떠올리는 사고 과정이 필요하다.
   - 커서를 인덱스로 만들어 이동하는 것이 아니라, 커서를 기준으로 왼쪽, 오른쪽 스택을 만들어 `pop()` `push()` 메서드로 `O(1)` 접근을 생각해야 한다.
2. 필요한 사고 과정
   1. 커서를 움직여볼까?
   2. 배열 중간 요소를 넣다 뻈다 하는 건 시간복잡도 문제가 생긴다
   3. (발상) 커서를 기준으로 왼쪽/오른쪽 스택을 만들어 삽입 삭제 연산을 진행한다.
