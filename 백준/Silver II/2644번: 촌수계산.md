[https://www.acmicpc.net/problem/2644](https://www.acmicpc.net/problem/2644)

```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

let index = 0;

// 전체 사람 수
const N = Number(input[index++]);

// 촌수를 구해야하는 서로 다른 두 사람
const [person1, person2] = input[index++].split(' ').map((i) => Number(i));

// 부모 자식 관계 수
const M = Number(input[index++]);

// 가계도 (인접 리스트)
const linkedList = Array.from({ length: N + 1 }, () => []);

// 방문 여부
const visited = Array.from({ length: N + 1 }, () => false);

// 가계도 그리기
for (let i = 0; i < M; i++) {
    // 부모, 자식
    const [x, y] = input[index++].split(' ').map((i) => Number(i));

    // 부모 배열에 자식을 연결한다.
    linkedList[x].push(y);
    linkedList[y].push(x); //양방향이라서 역으로도 이어준다.
}

// 촌수
let answer = -1;

//DFS 로직
function DFS(currentNode, currentCount) {
    // 종료 조건: 상대방에게 도착했을 때
    if (currentNode === person2) {
        answer = currentCount;
        return;
    }

    // 자식, 부모 관계 확인
    for (let node of linkedList[currentNode]) {
        // 만약 이전에 확인하지 않은 관계라면
        if (visited[node] === false) {
            visited[node] = true; // 방문 표시
            DFS(node, currentCount + 1); // 촌수 + 1 해서 재귀
        }
    }
}

linkedList[person1] === true; // 시작 위치 방문 표시
DFS(person1, 0); // 0촌수부터 시작

console.log(answer);
```

### 🔗 배운점
1. 촌수를 세는 `answer`는 전역 변수가 아니라, 함수의 인자로 넘겨야 한다.
   - `answer`를 전역으로 관리하면, DFS탐색이 막혀 되돌아올 때, 백트래킹 값을 복구해야하기 때문에 복잡하다.
   - 함수가 호출될 때마다 독립적인 콜 스택이 생성되므로, 인자로 넘겨진 값은 해당 재귀 단계에서만 유효한 '스냅샷'처럼 동작한다.
2. DFS 조건을 잘 파악하자.
   - 진입
   - 종료 조건
   - 재귀 호출

