[https://www.acmicpc.net/problem/30804](https://www.acmicpc.net/problem/30804)
```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

let inputIndex = 0;

// 과일의 개수(1~20만)
const N = Number(input[inputIndex++]);

// 과일들
const fruits = input[inputIndex++].split(' ').map(Number);

// 과일 종류: 0번 인덱스는 사용하지 않는다.
const fruitsCount = Array.from({ length: 10 }, () => 0);

// 현재 윈도우 과일 종류
let kindCount = 0;

// 왼쪽 인덱스
let left = 0;

// 최댓값
let answer = -Infinity;

// 선형 탐색
for (let right = 0; right < N; right++) {
    // 오른쪽 과일
    let rightFruit = fruits[right];

    // 처음 본 과일이라면 현재 윈도우 과일 타입 증가
    if (fruitsCount[rightFruit] === 0) {
        kindCount += 1;
    }
    // 윈도우 확장: right번째 과일 추가
    fruitsCount[rightFruit] += 1;

    // 윈도우 축소: 조건을 만족할 때까지 left이동
    while (kindCount > 2) {
        // left번째 과일
        let leftFruit = fruits[left];

        // 과일 제거
        fruitsCount[leftFruit] -= 1;

        // 만약 그 과일이 전부 사라졌다면 타입 감소
        if (fruitsCount[leftFruit] === 0) {
            kindCount--;
        }
        // 인덱스 증가
        left++;
    }

    // 최댓값 갱신
    answer = Math.max(answer, right - left + 1);
}
console.log(answer);
```
### 🔗 풀이
1. 🤔 판단해야할 것들
    1. 과일이 두 종류 이하인지 판단해야 한다.
    2. 어떤 종류를 빼야 과일 개수가 가장 많을지 판단해야 한다.

2. 👀 ❌ 방법1) 단순히 생각해봣을 때
    1. fruits에 과일 종류가 몇 개인지 파악
    2. 3개 이상이라면?
        - 앞에서 뺏을 때 과일 종류
        - 뒤에서 뺏을 때 과일 종류
        - 둘을 비교해서 더 나은 쪽을 선택한다.
    3. fruits에서 과일 종류가 2개 이하가 될 떄까지 반복
    4. 남아있는 과일 개수 파악
    - 🤔 굳이 매번 막대기에서 빼야 할까?
        - 어디까지 빼야할지 파악한 뒤에 한 번에 빼볼까?
        - 근데 빼는 경우의 수가 앞/뒤 두 가지이다.

3. 💡 역발상: 가변 길이 슬라이딩 윈도우
    - 오른쪽은 무조건 증가
    - 왼쪽은 조건이 깨졌을 때만 따라옴
        - 여기서 조건이란? 길이 내 과일 종류가 2개를 넘어갈 경우

4. 🤔 필요한 준비물
    1. 과일 종류 배열
        - 과일이 최대 10개이기 때문에 배열을 만들어 개수를 센다.
    2. 왼쪽 인덱스
    3. 윈도우 내부 상태를 추적하는 변수 (이 문제에서는 윈도우 내 과일 종류 개수)
    4. 결과값(최댓값)
### 🔗 배운점
1. 가변 슬라이딩 윈도우
   > 배열이나 문자열 같은 선형 데이터에서 조건에 따라 윈도우(범위)의 크기를 늘렸다 줄였다 하며 탐색하는 알고리즘
   - 핵심: `right` 포인터는 항상 확장하고, 조건이 깨지면 `left` 포인터가 쫓아가는 구조
   - 암기사항
     - 윈도우 인덱스가 `left ~ right`일 때, 현재 윈도우의 길이는 다음과 같다.
     - 길이 = `right - left + 1`
