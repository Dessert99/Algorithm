[https://www.acmicpc.net/problem/1012](https://www.acmicpc.net/problem/1012)

```javascript
const input = require('fs')
    .readFileSync(process.platform === 'linux' ? '/dev/stdin' : './input.txt')
    .toString()
    .trim()
    .split('\n');

// 인덱스 커서
let index = 0;

//가로, 세로, 배추개수
let M, N, K;

// 테스트 개수
const T = Number(input[index++]);

// 증분
const dx = [-1, 0, 1, 0];
const dy = [0, 1, 0, -1];

// 케이스 개수만큼
for (let i = 0; i < T; i++) {
    //정답
    let answer = 0;

    [M, N, K] = input[index++].split(' ').map(Number);

    // 배추밭과 방문 기록할 배열 준비. 이때, 세로를 먼저 넣어야 한다.
    const arr = Array.from({ length: N }, () => Array(M).fill(0));
    const visited = Array.from({ length: N }, () => Array(M).fill(0)); // 방문했다면 1

    // 배추 심기
    for (let j = 0; j < K; j++) {
        const [x, y] = input[index++].split(' ').map(Number); // 배추 좌표
        arr[y][x] = 1; // 심기
    }

    // 큐
    const queue = [];
    // 배추밭 스캔
    for (let n = 0; n < N; n++) {
        for (let m = 0; m < M; m++) {
            // 배추를 발견했고, 방문하지 않았다면
            if (arr[n][m] === 1 && visited[n][m] === 0) {
                answer++; // 배추 구역을 발견했으니 벌레 투입

                queue.push([n, m]); // BFS준비
                visited[n][m] = 1; // ⭐️ 방문 표시 해야 함
                while (queue.length > 0) {
                    let [y, x] = queue.shift(); // 현재 위치 좌표

                    // 이제 벌레가 커버 가능한 구역인지 확인한다. (주변 확인)
                    for (let k = 0; k < 4; k++) {
                        let nx = x + dx[k]; // ⭐️ 배열에서 꺼내야 함
                        let ny = y + dy[k];

                        if (
                            //조건1) 모서리 아니어야 함
                            nx >= 0 &&
                            ny >= 0 &&
                            ny < N &&
                            nx < M &&
                            arr[ny][nx] && //조건2) 배추가 있어야 함
                            visited[ny][nx] === 0 //조건3) 방문하지 않은 곳이어야 함
                        ) {
                            queue.push([ny, nx]); // 옆 배추 방문 예약
                            visited[ny][nx] = 1; // ⭐️ 방문 표시
                        }
                    }
                }
            }
        }
    }
    console.log(answer);
}
```

### 배운 점
1. 큐에 좌표를 넣을 때 즉시 방문 처리를 하지 않으면, 중복된 좌표가 큐에 쌓여 메모리 초과나 시간 초과가 발생할 수 있다.
- ❌ 큐에서 `shift()` 할 때 방문 처리.
- ✅ `queue.push()` 하는 순간 `visited[ny][nx] = 1` 처리.

2. 방향 벡터 연산 실수
- ❌ `nx = x + dx` : 배열 전체를 더하면 문자열이 되거나 `NaN`이 됨.
- ✅ `nx = x + dx[k]` : 반복문 안에서 `k`번째 인덱스 값을 가져와야 함.

3. 최적화 포인트
- `visited` 배열 제거: 이미 방문한 배추는 `0`으로 값을 바꿔버리면(배추를 뽑아버리면) 별도의 `visited` 배열 없이 메모리를 아낄 수 있다.
- `shift()` 성능: JS의 `shift()`는 $O(N)$이다. 데이터가 많을 경우 인덱스 포인터를 사용하거나 직접 큐를 구현해야 한다.

