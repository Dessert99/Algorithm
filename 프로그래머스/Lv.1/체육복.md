[https://school.programmers.co.kr/learn/courses/30/lessons/42862?language=javascript](https://school.programmers.co.kr/learn/courses/30/lessons/42862?language=javascript)
```javascript
function solution(n, lost, reserve) {
    let answer = n;

    // 체육복을 진짜 나눠줄 수 있는 사람들
    const realReserve = reserve.filter((item) => !lost.includes(item)).sort((a, b) => a - b);
    // 진짜 잃어버린 사람들
    const realLost = lost.filter((item) => !reserve.includes(item)).sort((a, b) => a - b);

    // 일단 옷이 있는 애들
    answer -= realLost.length;

    // 잃어버린 애들 앞,뒷번호 확인
    for (let L of realLost) {
        // 앞 번호 확인
        let searchIndex = realReserve.indexOf(L - 1);

        // 앞 번호가 있다면
        if (searchIndex !== -1) {
            answer++;
            realReserve.splice(searchIndex, 1); // 빌려줌 처리
        } else {
            // 뒷번호 확인
            searchIndex = realReserve.indexOf(L + 1);

            // 뒷 번호가 있다면
            if (searchIndex !== -1) {
                answer++;
                realReserve.splice(searchIndex, 1); // 빌려줌 처리
            }
        }
    }

    return answer;
}
```
### 🔗 배운점
1. 시간복잡도는 꼭 계산하자.
   - 이 문제에서 괜히 매번 include로 확인하면 시간복잡도를 초과할까 걱정했는데, 사실 `n`이 최대 30이다. 계산해보면 넉넉하다는 사실을 알 수 있다.
2. `filter()`는 원본 배열을 바꾸지 않는다..
   ```javascript
    realReserve.filter((item) => item !== L - 1); // 제거
   ```
   - 이 코드는 체육복을 빌려준 뒤, 목록에서 제거할 수 없다. `filter()`는 원본 배열을 바꾸지 않기 떄문이다. 여전히 `realReserve`배열에는 체육복을 빌려준 친구가 남아있다.
3. `indexOf()`, `splice()`사용법
   ```javascript
      const friends = ['철수', '영희', '민수'];
      console.log(friends.indexOf('영희')); // 1 (1번 방에 있음)
      console.log(friends.indexOf('바둑이')); // -1 (없음)
   ```
   ```javascript
    const numbers = [10, 20, 30, 40, 50];
      // 2번 인덱스(30)부터 1개를 지워라!
      numbers.splice(2, 1); 
      console.log(numbers); 
      // 결과: [10, 20, 40, 50] -> 30이 사라짐 (원본이 바뀜!)
   ```
   
