[https://school.programmers.co.kr/learn/courses/30/lessons/43165?language=javascript](https://school.programmers.co.kr/learn/courses/30/lessons/43165?language=javascript)

```javascript
function solution(numbers, target) {
    var answer = 0;
    const n = numbers.length
    
    function DFS(curIndex, sum){
    // 종료 조건) 모든 배열의 숫자를 계산함
        if (curIndex === n){
            // 누적합과 target이 같다면 answer++
            if (sum === target){
                answer++
                return
            }
            return
        }
        
        DFS(curIndex+1,sum+numbers[curIndex]) // 갈림길1 -> + 
        DFS(curIndex+1,sum-numbers[curIndex]) // 갈림길2 -> - 
}
    
    DFS(0, 0)  // 첫 번째 인덱스, 합계 0으로 시작
    
    return answer;
}
```
### 🔗 배운점
1. 시간복잡도 계산 잘하자.
   - 지금 최대 경위의 수가 $2^{20}$였다. 너무 큰 수라고 생각해서 1초를 초과할 것이라 생각햇는데, 1억을 넘지 않는다. 모든 경우의 수를 봐도 된다.
2. 방문 여부 배열이 필요가 없다.
   - 현재 DFS구조는 단방향으로 흐른다. 뒤로 갈 필요가 없으니, 방문 여부를 고려할 필요도 없다.
