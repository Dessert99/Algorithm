[https://school.programmers.co.kr/learn/courses/30/lessons/42626](https://school.programmers.co.kr/learn/courses/30/lessons/42626)
```javascript
class minHeap {
    constructor() {
        this.heap = [];
    }

    // 유틸
    getParentIndex(curIndex) {
        return Math.floor((curIndex - 1) / 2);
    }
    getLeftChildIndex(curIndex) {
        return curIndex * 2 + 1;
    }
    getRightChildIndex(curIndex) {
        return curIndex * 2 + 2;
    }

    swap(i1, i2) {
        [this.heap[i1], this.heap[i2]] = [this.heap[i2], this.heap[i1]];
    }

    // 넣기
    insert(value) {
        this.heap.push(value);
        this.heapifyUp();
    }

    // 정렬
    heapifyUp() {
        // 들어온 값 인덱스
        let curIndex = this.heap.length - 1;

        // 제자리를 찾아갈 때까지 반복한다.
        // 기본 종료 조건: curIndex가 0일 때
        while (curIndex > 0) {
            // 부모 인덱스 파악
            const parentIndex = this.getParentIndex(curIndex);

            // 종료 조건: 현재 값이 부모 이상일 때
            if (this.heap[parentIndex] <= this.heap[curIndex]) {
                // 최소힙은 인덱스가 작아질수록 값이 작아진다.
                break;
            }

            // 아직 현재 값이 부모보다 작다면 올려야 한다.
            this.swap(parentIndex, curIndex);
            curIndex = parentIndex;
        }
    }

    // 빼기
    extractMin() {
        // 힙이 비었다면 null 반환
        if (this.heap.length === 0) {
            return null;
        }
        // 힙에 값이 하나라도 그게 최솟값이다.
        if (this.heap.length === 1) {
            return this.heap.pop();
        }

        // 최솟값 빼놓기 (맨 앞에 있는 요소)
        const min = this.heap[0];

        // 전체적으로 정렬하기 위해서 맨 밑 요소를 루트로 끌어당긴다.
        this.heap[0] = this.heap.pop();

        // 정렬
        this.heapifyDown();

        // 최솟값 반환
        return min;
    }

    //정렬
    heapifyDown() {
        // 정렬 대상 인덱스. (초기값은 아까 루트로 올렸던 맨 마지막 값 인덱스)
        let curIndex = 0;

        // 최소힙 길이
        const length = this.heap.length;

        // 제자리를 찾아갈 때까지 반복
        while (true) {
            // 일단 현재 인덱스가 최솟값이라고 가정. 이후 왼쪽, 오른쪽 자식과 비교하며 결정한다.
            let minIndex = curIndex;
            // 왼쪽 자식 인덱스
            const leftChildIndex = this.getLeftChildIndex(curIndex);
            // 오른쪽 자식 인덱스
            const rightChildIndex = this.getRightChildIndex(curIndex);

            // 왼쪽 자식과 비교. 이때 배열 참조 에러를 피하려면, 인덱스가 유효한지 확인해야 한다.
            if (leftChildIndex < length && this.heap[leftChildIndex] < this.heap[minIndex]) {
                // 왼쪽 자식이 최솟값보다 작다면, 최솟값 인덱스를 바꾼다.
                minIndex = leftChildIndex;
            }

            // 오른쪽도 동일하게 비교한다.
            if (rightChildIndex < length && this.heap[rightChildIndex] < this.heap[minIndex]) {
                minIndex = rightChildIndex;
            }

            // 비교 이후에도 최솟값 인덱스가 바뀌지 않았다면 지금 위치가 적절하다는 의미이므로, 반복문을 종료한다.
            if (minIndex === curIndex) {
                break;
            }

            // 반복문이 종료되지 않았다면, 위치 조정이 필요하다는 의미이다.
            this.swap(minIndex, curIndex);
            curIndex = minIndex;
        }
    }
}

function solution(scoville, K) {
    let answer = 0;

    const heap = new MinHeap();

    // 배열 -> 힙
    scoville.forEach((s) => {
        heap.insert(s);
    });

    // 반복문 시작 (최솟값이 K 이상이 될 때까지)
    while (true) {
        const food1 = heap.extractMin();

        // 종료조건 : 최솟값 >= K 일 때
        if (food1 >= K) {
            break;
        }

        // 실패 조건 -> 아직 최솟값이 K 보다 작은데, 더 이상 꺼낼 두 번째 최솟값이 없다.
        if (heap.heap.length === 0) {
            return -1;
        }

        const food2 = heap.extractMin();
        const mixed = food1 + food2 * 2;
        answer++;

        heap.insert(mixed);
    }

    return answer;
}
```
### 🔗 풀이
1. `scoville` 배열을 최소 힙에 넣는다.
2. 종료 조건을 만족할 때까지 반복한다. 종료 조건은 모든 값이 `K` 이상을 만족할 때이다.
3. 첫 번째 음식을 꺼낸다.
4. ⭐️ 종료 조건을 확인한다. 만약 남은 힙에 요소가 없다면 음식을 조합할 수 없어 최솟값을 만들지 못한다.
5. 두 번째 음식을 꺼낸다.
6. 공식에 맞게 조합한 뒤 힙에 넣는다.

### 🔗 배운점
1. 종료 조건인 “모든 음식의 스코빌 지수가 K를 넘지 못하는 경우” 처리 방법
   - 처음에 단순히 scoville 배열을 더한 값을 K와 비교했다. 하지만 문제에서 주어진 공식이 있기 때문에 이렇게 비교하면 안된다.
   - 첫 번째 최솟값이 K를 넘지 못했는데, 더 이상 꺼낼 값이 없는 경우가 종료 조건이다.
     ```javascript
        if (food1 >= K) {
            break;
          }
     ```
2. 최소 힙 선택 이유
   - `scoville` 의 최대 길이는 백만이다. 매 턴마다 순회하며 찾을 수 없다. 한 번의 순회로 최소힙에 저장해놓고, 최솟값만 확인해야 한다.
