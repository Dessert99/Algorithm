[https://school.programmers.co.kr/learn/courses/30/lessons/42626](https://school.programmers.co.kr/learn/courses/30/lessons/42626)
```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }

    // ìœ í‹¸
    getParentIndex(curIndex) {
        return Math.floor((curIndex - 1) / 2);
    }
    getLeftChildIndex(curIndex) {
        return curIndex * 2 + 1;
    }
    getRightChildIndex(curIndex) {
        return curIndex * 2 + 2;
    }
    swap(i1, i2) {
        [this.heap[i1], this.heap[i2]] = [this.heap[i2], this.heap[i1]];
    }

    heapifyUp() {
        let curIndex = this.heap.length - 1;

        while (curIndex > 0) {
            // ë¶€ëª¨ ì¸ë±ìŠ¤ íŒŒì•…
            const parentIndex = this.getParentIndex(curIndex);
            // ë¶€ëª¨ <=ë‚˜
            if (this.heap[parentIndex] <= this.heap[curIndex]) {
                break;
            }

            // ë¶€ëª¨ > ë‚˜
            this.swap(curIndex, parentIndex);
            curIndex = parentIndex;
        }
    }
    // ë„£ê¸°
    insert(value) {
        this.heap.push(value);
        this.heapifyUp();
    }

    heapifyDown() {
        let curIndex = 0; //  ì •ë ¬ ëŒ€ìƒ
        const length = this.heap.length;

        while (true) {
            const leftChildIndex = curIndex * 2 + 1;
            const rightChildIndex = curIndex * 2 + 2;
            let min = curIndex;

            if (leftChildIndex < length && this.heap[leftChildIndex] < this.heap[min]) {
                min = leftChildIndex;
            }
            if (rightChildIndex < length && this.heap[rightChildIndex] < this.heap[min]) {
                min = rightChildIndex;
            }
            if (min === curIndex) {
                break;
            }

            this.swap(curIndex, min);
            curIndex = min;
        }
    }
    // ë¹¼ê¸°
    extractMin() {
        // í™ = 0
        if (this.heap.length === 0) {
            return null;
        }
        // í™ = 1
        if (this.heap.length === 1) {
            return this.heap.pop();
        }

        // ë‚´ë³´ë‚¼ ìµœì†Ÿê°’ (ë£¨íŠ¸)
        const min = this.heap[0];

        // ë§¨ ë°‘ ì˜¬ë¦¬ê¸°
        this.heap[0] = this.heap.pop();

        // ì •ë¦¬
        this.heapifyDown();

        return min;
    }
}

function solution(scoville, K) {
    let answer = 0;

    const heap = new MinHeap();

    // ë°°ì—´ -> í™
    scoville.forEach((s) => {
        heap.insert(s);
    });

    // ë°˜ë³µë¬¸ ì‹œì‘ (ìµœì†Ÿê°’ì´ K ì´ìƒì´ ë  ë•Œê¹Œì§€)
    while (true) {
        const food1 = heap.extractMin();

        // ì¢…ë£Œì¡°ê±´ : ìµœì†Ÿê°’ >= K ì¼ ë•Œ
        if (food1 >= K) {
            break;
        }

        // ì‹¤íŒ¨ ì¡°ê±´ -> ì•„ì§ ìµœì†Ÿê°’ì´ K ë³´ë‹¤ ì‘ì€ë°, ë” ì´ìƒ êº¼ë‚¼ ë‘ ë²ˆì§¸ ìµœì†Ÿê°’ì´ ì—†ë‹¤.
        if (heap.heap.length === 0) {
            return -1;
        }

        const food2 = heap.extractMin();
        const mixed = food1 + food2 * 2;
        answer++;

        heap.insert(mixed);
    }

    return answer;
}
```
### ğŸ”— í’€ì´
1. `scoville` ë°°ì—´ì„ ìµœì†Œ í™ì— ë„£ëŠ”ë‹¤.
2. ì¢…ë£Œ ì¡°ê±´ì„ ë§Œì¡±í•  ë•Œê¹Œì§€ ë°˜ë³µí•œë‹¤. ì¢…ë£Œ ì¡°ê±´ì€ ëª¨ë“  ê°’ì´ `K` ì´ìƒì„ ë§Œì¡±í•  ë•Œì´ë‹¤.
3. ì²« ë²ˆì§¸ ìŒì‹ì„ êº¼ë‚¸ë‹¤.
4. â­ï¸ ì¢…ë£Œ ì¡°ê±´ì„ í™•ì¸í•œë‹¤. ë§Œì•½ ë‚¨ì€ í™ì— ìš”ì†Œê°€ ì—†ë‹¤ë©´ ìŒì‹ì„ ì¡°í•©í•  ìˆ˜ ì—†ì–´ ìµœì†Ÿê°’ì„ ë§Œë“¤ì§€ ëª»í•œë‹¤.
5. ë‘ ë²ˆì§¸ ìŒì‹ì„ êº¼ë‚¸ë‹¤.
6. ê³µì‹ì— ë§ê²Œ ì¡°í•©í•œ ë’¤ í™ì— ë„£ëŠ”ë‹¤.

### ğŸ”— ë°°ìš´ì 
1. ì¢…ë£Œ ì¡°ê±´ì¸ â€œëª¨ë“  ìŒì‹ì˜ ìŠ¤ì½”ë¹Œ ì§€ìˆ˜ê°€ Kë¥¼ ë„˜ì§€ ëª»í•˜ëŠ” ê²½ìš°â€ ì²˜ë¦¬ ë°©ë²•
   - ì²˜ìŒì— ë‹¨ìˆœíˆ scoville ë°°ì—´ì„ ë”í•œ ê°’ì„ Kì™€ ë¹„êµí–ˆë‹¤. í•˜ì§€ë§Œ ë¬¸ì œì—ì„œ ì£¼ì–´ì§„ ê³µì‹ì´ ìˆê¸° ë•Œë¬¸ì— ì´ë ‡ê²Œ ë¹„êµí•˜ë©´ ì•ˆëœë‹¤.
   - ì²« ë²ˆì§¸ ìµœì†Ÿê°’ì´ Kë¥¼ ë„˜ì§€ ëª»í–ˆëŠ”ë°, ë” ì´ìƒ êº¼ë‚¼ ê°’ì´ ì—†ëŠ” ê²½ìš°ê°€ ì¢…ë£Œ ì¡°ê±´ì´ë‹¤.
     ```javascript
        if (food1 >= K) {
            break;
          }
     ```
2. ìµœì†Œ í™ ì„ íƒ ì´ìœ 
   - `scoville` ì˜ ìµœëŒ€ ê¸¸ì´ëŠ” ë°±ë§Œì´ë‹¤. ë§¤ í„´ë§ˆë‹¤ ìˆœíšŒí•˜ë©° ì°¾ì„ ìˆ˜ ì—†ë‹¤. í•œ ë²ˆì˜ ìˆœíšŒë¡œ ìµœì†Œí™ì— ì €ì¥í•´ë†“ê³ , ìµœì†Ÿê°’ë§Œ í™•ì¸í•´ì•¼ í•œë‹¤.
