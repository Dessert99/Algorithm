[https://school.programmers.co.kr/learn/courses/30/lessons/42587?language=javascript](https://school.programmers.co.kr/learn/courses/30/lessons/42587?language=javascript)
```javascript
function solution(priorities, location) {
    let answer = 0;
    const queue = [];

    // 큐에 우선 순위 + 위치 정보를 함께 저장한다.
    priorities.forEach((priority, idx) => {
        queue.push([priority, idx]);
    });

    while (true) {
        const [curPriority, curPosition] = queue.shift();

        // 만약 현재 큐에 어떤 요소라도 현재 우선순위보다 높다면
        if (queue.some(([priority]) => curPriority < priority)) {
            // 그대로 맨 뒤에 넣는다.
            queue.push([curPriority, curPosition]);
        } else {
            // 우선순위가 높지 않다면
            answer++;

            // 현재 프로세스의 위치가 찾던 위치라면 종료
            if (location === curPosition) {
                return answer;
            }
        }
    }
}

console.log(solution([2, 1, 3, 2], 2));
console.log(solution([1, 1, 9, 1, 1, 1], 0));
```
### 🔗 풀이
1. priorities 배열의 우선순위 요소에 “현재 위치” 정보를 추가한다.
2. while문을 반복한다.
3. priorities 배열의 맨 앞 요소를 꺼낸다.
4. priorities 배열을 돌며 우선순위를 확인한다.
5. 만약 현재 우선순위보다 더 높은 우선순위가 있다면 즉시 priorities배열 맨 뒤로 이동한다.
6. 현재 우선순위가 가장 높다면 answer + 1 한다.
7. 만약 현재 위치와 location이 동일하다면 반복문을 종료하고 answer를 출력한다.
### 🔗 배운점
1. 단순하게 풀어도 시간복잡도를 초과하지 않는 이유
    - 제한사항을 숙지한다. → `priorities`길이는 최대 100
    - 시간복잡도를 생각해본다. → $N=100$이면 **$O(N^3)$까지 안전하다.**
    - 문제를 분석한다. → 가장 앞에 있는 문서를 대기 목록 맨 뒤로 보낸다. → N이 작아서 그냥 반복문 돌려도 안전하다.
2.  `some()`  메서드 구현해보기
    - 자바스크립트 내장 함수 `Array.prototype.some` 는 배열의 요소 중 하나라도 콜백 함수가 true를 반환하면 true 가된다. ?
    
    ```tsx
    function mySome(array, callback) {
    
    		// for문은 제어문이기 때문에, 내부에서 return, break 사용이 가능하다.
        for (let i = 0; i < array.length; i++) {
            if (callback(array[i])) {
                return true;
            }
        }
        return false;
    }
    
    const priority = 7;
    
    console.log(mySome([9, 8, 51, 7, 8], (element) => element < priority));
    console.log(mySome([2, 1, 5, 6, 4, 2], (element) => element < priority));
    ```
    
    - 조건을 만족한다면 함수를 조기 종료하여 성능을 높이기 위해 `for`문을 사용한다.
3. `map()` 메서드 사용하기
    
    ```tsx
    const queue = [];
    priorities.forEach((priority, idx) => {
        queue.push([priority, idx]);
    });
    ```
    
    ```tsx
    // 인덱스(idx)를 함께 저장하는 패턴은 매우 자주 쓰인다.
    const queue = priorities.map((priority, idx) => [priority, idx]);
    ```
    
4. `forEach()`는 중간에 멈출 수 없다.
    - `forEach()`는 배열이 가진 메서드이고, 안에 전달하는 것은 콜백 함수이다. `return` 을 사용해도 현재 블록이 종료하는 것이 아니라, “이번 턴”이 끝났다는 의미라서, 다음 턴을 실행하게 된다.
