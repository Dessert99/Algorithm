[https://school.programmers.co.kr/learn/courses/30/lessons/59047](https://school.programmers.co.kr/learn/courses/30/lessons/59047)
```sql
-- 코드를 입력하세요
SELECT
    ANIMAL_ID,
    NAME

FROM
    ANIMAL_INS

WHERE
    NAME REGEXP 'EL' AND -- el포함
    ANIMAL_TYPE = 'Dog'

ORDER BY
    NAME
```
### 🔗 풀이


### 🔗 배운점 : SQL 정규식(`REGEXP`) 문법 총정리
> 정규식은 `WHERE 컬럼명 REGEXP '패턴'` 형태로 사용합니다.
1. 특정 문자 및 위치 지정
    | **문법** | **설명** | **예시 코드** | **매칭 결과 (O)** | **매칭 실패 (X)** |
    | --- | --- | --- | --- | --- |
    | `^` | 문자열의 시작 | `NAME REGEXP '^A'` | **A**pple, **A**nt | Banana |
    | `$` | 문자열의 끝 | `NAME REGEXP 's$'` | Dog**s**, Cat**s** | Mouse |
    | `.` | 임의의 문자 1개 | `NAME REGEXP 'a.c'` | **aac**, **abc**, **a1c** | ac, abbc |
2. 반복 (수량자)
    | **문법** | **설명** | **예시 코드** | **매칭 결과 (O)** | **매칭 실패 (X)** |
    | --- | --- | --- | --- | --- |
    | `*` | 앞의 문자가 0회 이상 반복 | `NAME REGEXP 'a*b'` | **b**, **ab**, **aab** | a |
    | `+` | 앞의 문자가 1회 이상 반복 | `NAME REGEXP 'a+b'` | **ab**, **aab** | b (a가 없음) |
    | `?` | 앞의 문자가 0회 또는 1회 | `NAME REGEXP 'a?b'` | **b**, **ab** | aab |
3. 그룹화 및 범위 지정
    | **문법** | **설명** | **예시 코드** | **매칭 결과 (O)** | **매칭 실패 (X)** |
    | --- | --- | --- | --- | --- |
    | `I` | OR (또는) | `NAME REGEXP 'AIB'` | **A**pple, **B**anana | Cherry |
    | `[...]` | 괄호 안의 문자 중 하나라도 포함 | `NAME REGEXP '[abc]'` | **a**pple, **c**at | dog |
    | `[a-z]` | a부터 z까지 (소문자 포함 여부) | `NAME REGEXP '[a-z]'` | **b**oy, **g**irl | 123 |
    | `[0-9]` | 0부터 9까지 (숫자 포함 여부) | `NAME REGEXP '[0-9]'` | test**1**, **2**nd | test |
    | `[^...]` | 괄호 안의 문자를 **제외**한 것 | `NAME REGEXP '[^a-c]'` | **d**og, **e**lephant | a, b, c (단독) |
4. 여러 단어 중 하나로 시작하는 데이터 (접두사)
    > '서울', '경기', '인천' 중 하나로 시작하는 주소 찾기
    - **정규식:**
      - `REGEXP '^(서울|경기|인천)'`
    - **문법 해석:**
      - 맨 앞의 `^`는 문자열의 시작을 의미합니다. `( )`로 그룹을 묶고 그 안에 `|`(OR 연산자)를 사용해, 괄호 안의 단어들 중 하나로만 시작하면 참(True)으로 판별합니다.
5. 특정 확장자나 단어로 끝나는 데이터 (접미사)
    > 파일명이 'txt', 'pdf', 'docx' 중 하나로 끝나는 데이터 찾기
    - **정규식:**
      - `REGEXP '\\.(txt|pdf|docx)$'`
    - **문법 해석:**
      - `$`는 문자열의 끝을 의미합니다. 점(`.`)은 원래 정규식에서 '임의의 문자 1개'를 뜻하므로, 진짜 마침표 기호 그 자체를 찾으려면 앞에 역슬래시 두 개(`\\`)를 붙여 이스케이프(Escape) 처리를 해야 합니다. (이메일 도메인 검사에도 자주 쓰입니다.)
6. 여러 키워드 중 하나라도 포함된 데이터 (부분 일치)
    > 주소 중간에 '강남', '서초', '송파' 중 하나라도 들어간 데이터 찾기
    - **정규식:**
      - `REGEXP '강남|서초|송파'`
    - **문법 해석:**
      - 시작(`^`)이나 끝(`$`) 기호 없이 단어들을 `|`로만 연결했습니다. 이렇게 작성하면 문자열 내의 위치와 상관없이 해당 단어 중 하나라도 포함되어 있으면 모두 찾아냅니다.
7. 자릿수가 고정된 숫자 패턴 (포맷 검증)
    > '010-숫자4자리-숫자4자리' 형태의 올바른 전화번호 찾기
    - **정규식:**
      - `REGEXP '^010-[0-9]{4}-[0-9]{4}$'`
    - **문법 해석:**
      - `[0-9]`는 숫자를 뜻하고, 중괄호 `{4}`는 바로 앞의 패턴(숫자)이 정확히 4번 반복된다는 의미입니다. 양끝을 `^`와 `$`로 막아두었기 때문에 앞뒤로 다른 불필요한 문자가 붙어있는 데이터를 걸러내고 정확한 규격만 찾습니다.
8. 특정 문자가 완전히 배제된 데이터 (부정형)
    > 이름에 숫자가 아예 섞이지 않고 문자로만 이루어진 데이터 찾기
    - **정규식:**
      - `REGEXP '^[^0-9]+$'`
    - **문법 해석:**
      - 대괄호 안의 `^`는 시작이 아니라 **'제외(NOT)'**를 의미합니다. 즉, `[^0-9]`는 '숫자가 아닌 것'입니다. 뒤에 붙은 `+`는 1번 이상 반복을 뜻하므로, "처음(`^`)부터 끝(`$`)까지 숫자가 아닌 것들로만 쭉 이어져 있다"는 뜻이 됩니다.
9. 텍스트 중간에 숨은 '정확한 자릿수' 찾기
    - `LIKE '%[0-9][0-9][0-9]%'` 같은 방식은 숫자 3개가 연속된 것은 찾지만, 숫자가 4개, 5개 연속된 것('A1234B')도 같이 찾아버리는 치명적인 문제가 있습니다. 정확히 특정 자릿수만 끊어서 찾는 건 정규식이 필요합니다.
    > 텍스트 중간에 숫자가 정확히 3자리만 연속으로 등장하는 데이터 (예: "abc123def" -> 참, "a1234b" -> 거짓)
    - 정규식
      - `REGEXP '(^|[^0-9])[0-9]{3}([^0-9]|$)'`
    - 문법 해석
      - `* [0-9]{3}`: 숫자가 정확히 3번 반복됨을 의미합니다.
      - `(^|[^0-9])`: 그 숫자 3자리 앞에는 문자열의 시작(`^`)이거나 숫자가 아닌 문자(`[^0-9]`)가 와야 합니다.
      - `([^0-9]|$)`: 그 숫자 3자리 뒤에는 숫자가 아닌 문자(`[^0-9]`)가 오거나 문자열이 끝나야(`$`) 합니다.
10. 패턴의 반복과 변칙적인 기호 조합
    - 이메일이나 URL처럼 '규칙은 있지만 길이나 들어가는 문자가 제각각'인 데이터의 유효성을 검증할 때는 정규식 외에는 답이 없습니다.
    > 이메일 아이디 부분에 점(.)이 연속으로 두 번 이상 들어갔거나, 특수문자로 시작하는 불량 이메일 찾기
    - 정규식:
      - `REGEXP '^[!@#%^&*]|\\.{2,}.*@'`
    - 문법 해석:
      - `* | (OR)`를 기준으로 두 가지 불량 패턴을 잡습니다.
      - `^[!@#%^&*]`: 시작(`^`) 문자가 괄호 안의 특수문자 중 하나인 경우.
      - `\\.{2,}.*@`: 진짜 마침표(`\\.`)가 2번 이상(`{2,}`) 반복되고, 그 뒤에 임의의 문자들(`.*`)이 오다가 골뱅이(`@`)가 나오는 경우. `LIKE`로는 무한한 길이의 텍스트에서 점 두 개의 위치를 특정하기 불가능합니다.
