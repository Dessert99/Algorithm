[https://school.programmers.co.kr/learn/courses/30/lessons/42584](https://school.programmers.co.kr/learn/courses/30/lessons/42584)
```javascript
function solution(prices) {
    const n = prices.length;

    // 정답 배열을 0으로 채운다. 인덱스를 사용해야하기 때문이다.
    const answer = Array.from({ length: n }, () => 0);

    // prices 인덱스를 저장할 스택
    const stack = [];

    let count = 0;

    for (let i = 0; i < n; i++) {
        // 1초 증가
        count++;
        const curPrice = prices[i];

        // 스택에서 하나씩 꺼내며, 현재 가격과 비교한다.
        while (stack.length !== 0 && prices[stack[stack.length - 1][0]] > curPrice) {
            // 떨어진 가격의 인섹스
            const [droppedPriceIndex, inputCount] = stack.pop();

            // 떨어진 가격의 인덱스를 활용하여 떨어지지 않은 기간을 넣는다.
            answer[droppedPriceIndex] = count - inputCount;
        }

        // 스택에 현재 가격의 인덱스와 들어간 시간대를 넣는다.
        stack.push([i, count]);
    }

    // 스택에 남은 요소들은 전부 끝까지 떨어지지 않은 요소들이다.
    while (stack.length !== 0) {
        const [priceIndex, inputCount] = stack.pop();
        answer[priceIndex] = count - inputCount;
    }

    return answer;
}
```
### 🔗 풀이
1. 스택을 생성한다. (가격의 인덱스를 넣는다.)
2. 누적 시간을 저장할 변수 `count`를 만든다.
3. prices 배열을 순회한다.
    - 그 안에서 스택에서 요소를 빼내는 반복문을 실행한다.
        - 조건) 스택에 요소가 있고, 스택 맨 위 인덱스의 가격이 현재 가격보다 클 경우
            - 가격이 떨어졌으므로, 스택에서 꺼낸다.
            - 현재 가격이 떨어지지 않은 기간을 계산하여 `answer`에 넣는다.
    - 현재 가격의 인덱스를 스택에 넣는다.
4. 순회를 멈추고 스택에 남아있는 가격들을 `answer`에 넣는다.

### 🔗 배운점
1. 스택을 사용해 과거 가격 기억하는 방법
    
    > 스택에 `prices` 인덱스를 집어 넣는다.
    > 
    - 인덱스를 사용하여 `prices` 요소가 현재 가격보다 낮은 값인지 확인하고, 맞다면 스택에서 제거한다.
2. 스택에서 꺼낸 가격이 현재 가격보다 작다면, 그 아래 가격도 작을 것이라는 근거가 어디에 있는가?
    
    > 스택에 넣는 구조 자체를 그렇게 설계했다.
    > 
    - `push()` 위치를 보면, 현재 가격보다 낮은 경우에만 스택에 넣게끔 설계되어 있다.
