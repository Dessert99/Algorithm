[https://school.programmers.co.kr/learn/courses/30/lessons/43238?language=javascript](https://school.programmers.co.kr/learn/courses/30/lessons/43238?language=javascript)
```javascript
function solution(n, times) {
    // 정렬하면 끝에 가장 오래 심사하는 심사관 시간이 남는다.
    times.sort((a, b) => a - b);
    
    let answer = 0;
    
    let start =1
    
    // 최약의 경우: 가장 긴 심사 시간을 가진 심사관이 n명의 사람을 혼자서 모두 심사할 때.
    let end = times[times.length - 1] * n;
    
    while(start<=end){
        // 모든 심사가 끝나는 시간 추정
        const mid = Math.floor((start+end)/2)
        
        // 모든 심사가 끝날 수 있다면
        if (isCheck(mid)){
            answer = mid
            end = mid-1 // 시간 줄여서 재시도
        }else{
            // 시간이 부족하다면 시간 늘려서 재시도
            start = mid +1
        }
    }
    return answer;
    
    // 주어진 mid시간 안에 모든 심사가 끝날 수 있는지 체크하는 함수
    function isCheck(mid){
        // 실세 심사한 인원 수
        let total = 0
        
        // 각 심사관이 mid시간만큼 처리할 수 있는 사람의 수를 total에 더한다.
        for (let time of times){
            total += Math.floor((mid)/time)
        }
        
        // n명의 사람을 모두 처리할 수 있다면 true
        if (total>=n){
            return true
        }else{
            return false
        }
    }
}
```
### 🔗 풀이
1. 💡 시간복잡도
    1. 심사할 사람 최대 10억 명
    2. 심사관의 최대 심사 시간 10억 분
    3. 심사관 최대 10만 명
    - 입력 조건이 너무 크다. "모든 사람이 심사를 받는데 걸리는 시간" 범위를 이분탐색으로 검사해야 한다.
2. 👀 방법1)
    1. 시작-끝을 정한다.
    2. 이분 탐색을 시작한다.
    3. 중간값이 모든 사람을 심사할 수 있다면 더 적은 시간이 가능한지 재탐색한다.
    4. 모든 사람을 심사할 수 없다면, 시간을 늘려서 재탐색한다.
    5. 이떄, "모든 사람을 심사할 수 있는지" 판단하는 로직은 다음과 같다.
        - `times`배열을 돌며 `Math.floor(mid/time)` 누적값을 구한다.
        - 심사관은 동시에 심사할 수 있기 때문에, 만약 `mid=20`시간 일때, 면접관 두 명이 3시간, 2시간이라면, 20/3 = 6  +  20/2 = 10. : 20시간 안에 최대 16명을 통과시킬 수 있다.
    
### 🔗 배운점
1. 이분 탐색 문제에서 고려해야할 부분들
   1. `start`, `end` 설정
      - 이건 문제 조건을 자세히 봐야 한다.
   3. `isCheck()` 메서드
      - 현재 `mid`값이 조건에 부합하는지 확인하는 함수이다. 따로 분리해서 true/false만 반환하게 만드는게 가독성에 좋다.
3. 스프레드 연산자 내부 동작
    
    > 스프레드 연산자가 펼친 10만 개의 요소는 호출 스택에 들어가게 되는데, 너무 많은 요소가 한 번에 몰리면 오류가 날 수도 있다. `RangeError: Maximum call stack size exceeded`
    > 
    
    ```jsx
    ❌ Math.max(...times)
    ```
    
    1. 배열 `times`를 메모리에서 꺼낸다.
    2. `...` 연산자가 배열의 요소를 하나하나 쪼개서 스택(Stack)에 쌓는다.
    3. 마치 우리가 코드로 `Math.max(t[0], t[1], t[2], ... t[99999])`라고 10만 개를 타이핑한 것과 똑같이 변환된다.
    4. 브라우저마다 다르지만, 보통 인자 개수가 65,536개($2^{16}$) 를 넘어가면 `RangeError: Maximum call stack size exceeded` 가 발생할 위험이 있다.
    - 해결 방안
        
        ```jsx
        // 1. 정렬하고
        times.sort((a,b) => a-b)
        
        // 2. 가장 큰 값을 사용한다.
        times[times.length-1]
        ```
        
4. 자바스크립트 숫자 자료형 정리
    
    > 숫자가 크다면 `Number`가 아닌 `Bigint`를 써야 한다.
    > 
    
    | **특징** | **Number (기본 숫자)** | **BigInt (큰 정수)** |
    | --- | --- | --- |
    | **정의** | 64비트 부동소수점 (IEEE 754) | 임의 정밀도 정수 (Arbitrary-precision) |
    | **안전한 최댓값** | **약 $9,000$조** ($2^{53} - 1$)
    `9,007,199,254,740,991` | **제한 없음**
    (메모리가 허용하는 한 무한대) |
    | **소수점 표현** | 가능 (`3.14`) | **불가능** (정수만 표현, 소수점 버림) |
    | **사용법** | `10`, `3.5` | `10n`, `BigInt(10)` |
    | **이 문제에서의 한계** | 최악의 경우($10^{18}$, 100경)를 담을 수 없음.
    오차가 발생하여 계산이 틀림. | $10^{18}$은 가볍게 처리 가능.
    **오차 없이 정확함.** |
    | **주의사항** | 정밀도가 떨어지는 구간이 존재함 | `Number` 타입과 섞어서 연산 불가 (`10n + 5` ❌ → `10n + 5n` ⭕) |
