[https://school.programmers.co.kr/learn/courses/30/lessons/42579?language=javascript](https://school.programmers.co.kr/learn/courses/30/lessons/42579?language=javascript)
```javascript
function solution(genres, plays) {
    const n = genres.length;

    const map = new Map();

    // 배열 -> 해시맵
    for (let i = 0; i < n; i++) {
        const curGenre = genres[i];
        const curPlay = plays[i];

        // 초기화
        if (!map.has(curGenre)) {
            map.set(curGenre, {
                totalPlay: 0,
                songs: [],
            });
        }

        // 참조값 가져오기
        const genreData = map.get(curGenre);

        // 총 재생 횟수 누적
        genreData.totalPlay += curPlay;

        // 장르에 노래 추가
        genreData.songs.push({ id: i, play: curPlay });
    }

    // map -> 배열 + 정렬1) totalPlay 내림차
    const sortedGenres = [...map].sort((a, b) => b[1].totalPlay - a[1].totalPlay);

    const answer = sortedGenres.flatMap(([key, value]) => {
        const sortedSongs = value.songs.sort((a, b) => {
            //  play가 같다면, id 오름차 -> 동률 조건을 먼저 고려한다.
            if (a.play === b.play) {
                return a.id - b.id;
            }

            // 장르 내에서 play 내림차
            return b.play - a.play;
        });
        // id만 출력
        return sortedSongs.slice(0, 2).map((song) => song.id);
    });

    return answer;
}

console.log(solution(['classic', 'pop', 'classic', 'classic', 'pop'], [500, 600, 150, 800, 2500]));
```
### 🔗 풀이
1. 장르가 key, 재생 횟수 리스트를 value로 한 map을 만든다.
    
    ```javascript
    // map에서 value값
    {
    'totalPlay' : 0
    'songs' : [ { id:0, play:300}, {id:1, play:2500} ... ]
    }
    ```
    
    - 속한 노래가 많이 재생된 장르를 파악해야하기 떄문에 `totalPlay` 값을 누적한다.
    - 장르별 모든 노래를 id, play 객체 형태로 배열에 추가한다.
2. 정렬하기 위해 map을 배열로 바꾼다.
3. totalPaly 기준으로 정렬한다.
4. 장르별 노래들을 정렬한다.
5. 노래 재생 횟수가 같다면 고유 번호로 정렬한다.
### 🔗 배운점
1. 자바스크립트 엔진에서 `sort()` 성능
    
    > $O(N \log N)$
    > 
    - V8엔진에서는Timsort이라는 알고리즘을 사용한다. 이 알고리즘은 병합 정렬과 삽입 정렬의 장점을 합친 하이브리드 알고리즘이다.
        - 현재 문제에서 최악의 경우, 장르 하나에 1만 개의 노래가 있어, 그들 중 재생 횟수가 많은 순서대로 정렬 후 앞에서 2곡을 짤라야 한다. $\log_2 N \approx 13.3$ 이기 때문에, 1만 * 13.3 = 약 13만 번의 연산을 한다. 여유롭다.
2. 다중 조건 정렬
    
    > 정렬 기준이 여러 개일 때는 우선순위가 낮은(혹은 예외적인) 조건을 `if`문으로 먼저 처리해야 한다.
    > 
    
    ```jsx
    songs.sort((a, b) => {
        // [2순위 조건] 재생 횟수가 같다면? (동점자 처리)
        if (a.play === b.play) {
            return a.id - b.id; // 오름차순 (작은 id가 먼저)
        }
        // [1순위 조건] 기본적으로 재생 횟수로 비교
        return b.play - a.play; // 내림차순 (큰 play가 먼저)
    });
    ```
    
3. 원시 타입 vs 참조 타입
    
    > 자바스크립트의 객체는 메모리 힙에 저장되고, 변수는 그 주소값만 가진다.
    > 
    - 원시 타입 (Primitive Type)
        
        > 값이 담긴 **데이터 그 자체**를 변수에 저장한다.
        > 
        - 특징: 불변성(Immutability). 한 번 생성된 값은 메모리 상에서 변경되지 않습니다.
        - **종류 (7가지):** `Number`, `String`, `Boolean`, `null`, `undefined`, `Symbol`, `BigInt`
    - 참조 타입 (Reference Type)
        
        > 데이터 자체가 아니라, 데이터가 위치한 메모리 주소(Reference)를 변수에 저장한다.
        > 
        - **특징:** **가변성(Mutability)**. 주소를 통해 접근하여 내부의 값을 변경할 수 있습니다.
        - **종류:** `Object` (Array, Function, Date, Map, Set 등 객체 하위의 모든 것)
4. `flatMap()` vs `map()`
    
    > 2차원 배열을 1차원으로 펴면서 변환할 때 사용하는 모던 메서드
    > 
    - 언제쓸까?
        
        장르별(1차)로 노래들(2차)을 뽑아서 하나의 리스트로 만들고 싶을 때.
        
    - 차이점
        - `map()` 사용 시: `[[1, 2], [3, 4]]` $\rightarrow$ 2차원 배열 발생 (불편).
        - `flatMap()` 사용 시: `[1, 2, 3, 4]` $\rightarrow$ 알아서 평탄화(Flat)까지 완료.
